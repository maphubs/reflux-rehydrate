{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///./dist/reflux-rehydrate.min.js","webpack:///webpack/bootstrap 85ad1bdbe43049037386","webpack:///./lib/index.js","webpack:///./~/reflux/src/index.js","webpack:///./~/reflux-core/lib/index.js","webpack:///./~/reflux-core/lib/ActionMethods.js","webpack:///./~/reflux-core/lib/ListenerMethods.js","webpack:///./~/reflux-core/lib/utils.js","webpack:///./~/eventemitter3/index.js","webpack:///./~/reflux-core/lib/joins.js","webpack:///./~/reflux-core/lib/createStore.js","webpack:///./~/reflux-core/lib/Keep.js","webpack:///./~/reflux-core/lib/mixer.js","webpack:///./~/reflux-core/lib/bindMethods.js","webpack:///./~/reflux-core/lib/StoreMethods.js","webpack:///./~/reflux-core/lib/PublisherMethods.js","webpack:///./~/reflux-core/lib/createAction.js","webpack:///./~/reflux/src/connect.js","webpack:///./~/reflux/src/ListenerMixin.js","webpack:///./~/reflux/src/connectFilter.js","webpack:///./~/reflux/src/listenTo.js","webpack:///./~/reflux/src/listenToMany.js","webpack:///./~/reflux/src/addES6.js","webpack:///./~/reflux/src/defineReact.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}"],"names":["root","factory","exports","module","require","e","define","amd","this","__WEBPACK_EXTERNAL_MODULE_22__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","initStore","str","prototype","rehydrate","state","setState","_reflux2","createActions","actions","rehydrateActions","concat","Object","defineProperty","value","_reflux","data","Reflux","serverMode","window","connect","connectFilter","ListenerMixin","listenTo","listenToMany","_interopRequireWildcard","newObj","key","hasOwnProperty","setEventEmitter","ctx","_","EventEmitter","nextTick","use","pluginCb","__keep","joinConcat","joinStrict","joinLeading","all","joinTrailing","createStore","createAction","utils","StoreMethods","PublisherMethods","ListenerMethods","ActionMethods","version","undefined","_ActionMethods","_ListenerMethods","_PublisherMethods","_StoreMethods","_joins","_utils","_createAction","_createStore","_Keep","reflux-core","staticJoinCreator","reducer","definitions","keys","forEach","actionName","val","Array","isObject","get","Function","bind","console","error","fetchInitialState","stopListeningToAll","stopListeningTo","validateListening","hasListener","mapChildListenables","listenable","childName","i","children","length","flattenListenables","listenables","flattened","childMap","childKey","childListenable","capitalize","j","listener","subscriptions","allListenables","cbname","callbackName","localname","isFunction","listen","callback","defaultCallback","desub","unsubscriber","subscriptionobj","subs","throwIf","index","indexOf","splice","stop","push","sub","remaining","me","getInitialState","then","apply","arguments","instanceJoinCreator","string","charAt","toUpperCase","slice","prefix","type","_typeof","extend","source","prop","getOwnPropertyDescriptor","propertyDescriptor","setTimeout","object","vals","o","isArguments","msg","Error","Symbol","iterator","constructor","EE","fn","context","once","has","create","_events","eventNames","name","events","names","getOwnPropertySymbols","listeners","event","exists","evt","available","l","ee","emit","a1","a2","a3","a4","a5","args","len","removeListener","on","removeAllListeners","off","addListener","setMaxListeners","prefixed","strategy","init","strategyMethodNames","subobj","pop","numberOfListenables","join","cancels","newListener","reset","makeStopper","listenablesEmitted","callargs","emitIfAllListenablesEmitted","strict","first","last","definition","Store","arr","emitter","eventLabel","_bindMethods","bindMethods","a","allowed","d","_mixer","mix","store","Keep","addStore","preEmit","shouldEmit","useKeep","bool","createdStores","addAction","act","createdActions","def","composed","updated","mixDef","mixin","mixed","mixins","subMixin","composable","reduce","newValue","some","property","deferWith","triggerAsync","trigger","bindContext","eventHandler","aborted","pre","oldTrigger","resolver","asyncResult","childActions","chDef","chName","_isAction","functor","hasChildActions","ignore","async","sync","triggerType","componentDidMount","v","componentWillUnmount","filterFunc","result","initial","defineReact","inherits","subClass","superClass","TypeError","enumerable","writable","configurable","setPrototypeOf","__proto__","React","R","react","noLongerUsed","proto","_extend","_react","Component","_defined","RefluxComponent","props","updater","storeKeys","componentWillMount","isArray","stores","unshift","__storeunsubscribes__","sS","onStoreTrigger","updateObj","filterByStoreKeys","ii","storeId","singleton","GlobalState","__readytomap__","dmaps","__delayedmaps__","jj","func","mapStoreToState","onMapStoreTrigger","update","self","hasProps","check","clss","PureComponent","RefluxStore","__store__","set","__listenables__","Combined","getGlobalState","clone","setGlobalState","storeID","initializeGlobalStore","inst","doUpdate","frm","to","Date","RegExp","String","Number","Boolean","code"],"mappings":"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","file":"/Users/kris/dev/maphubs/reflux-rehydrate/dist/reflux-rehydrate.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory((function webpackLoadOptionalExternalModule() { try { return require(\"react\"); } catch(e) {} }()));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RefluxRehydrate\"] = factory((function webpackLoadOptionalExternalModule() { try { return require(\"react\"); } catch(e) {} }()));\n\telse\n\t\troot[\"RefluxRehydrate\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_22__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory((function webpackLoadOptionalExternalModule() { try { return require(\"react\"); } catch(e) {} }()));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RefluxRehydrate\"] = factory((function webpackLoadOptionalExternalModule() { try { return require(\"react\"); } catch(e) {} }()));\n\telse\n\t\troot[\"RefluxRehydrate\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_22__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.initStore = initStore;\n\texports.createActions = createActions;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _reflux = __webpack_require__(1);\n\t\n\tvar _reflux2 = _interopRequireDefault(_reflux);\n\t\n\t_reflux2['default'].rehydrate = function (str, data) {\n\t  return _reflux2['default'].initStore(str).setState(data);\n\t};\n\t\n\texports['default'] = _reflux2['default'];\n\t\n\tfunction initStore(str) {\n\t  str.prototype.rehydrate = function (state) {\n\t    this.setState(state);\n\t  };\n\t  return _reflux2['default'].initStore(str);\n\t}\n\t\n\tfunction createActions(actions) {\n\t  var rehydrateActions = ['rehydrate'];\n\t  actions = rehydrateActions.concat(actions);\n\t  return _reflux2['default'].createActions(actions);\n\t}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Reflux = __webpack_require__(2);\r\n\t\r\n\tReflux.serverMode = typeof window !== 'object';\r\n\t\r\n\tReflux.connect = __webpack_require__(15);\r\n\t\r\n\tReflux.connectFilter = __webpack_require__(17);\r\n\t\r\n\tReflux.ListenerMixin = __webpack_require__(16);\r\n\t\r\n\tReflux.listenTo = __webpack_require__(18);\r\n\t\r\n\tReflux.listenToMany = __webpack_require__(19);\r\n\t\r\n\t__webpack_require__(20);\r\n\t\r\n\tmodule.exports = Reflux;\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.__keep = exports.joinConcat = exports.joinStrict = exports.joinLeading = exports.all = exports.joinTrailing = exports.use = exports.nextTick = exports.setEventEmitter = exports.createActions = exports.createStore = exports.createAction = exports.utils = exports.StoreMethods = exports.PublisherMethods = exports.ListenerMethods = exports.ActionMethods = exports.version = undefined;\n\t\n\tvar _ActionMethods = __webpack_require__(3);\n\t\n\tvar ActionMethods = _interopRequireWildcard(_ActionMethods);\n\t\n\tvar _ListenerMethods = __webpack_require__(4);\n\t\n\tvar ListenerMethods = _interopRequireWildcard(_ListenerMethods);\n\t\n\tvar _PublisherMethods = __webpack_require__(13);\n\t\n\tvar PublisherMethods = _interopRequireWildcard(_PublisherMethods);\n\t\n\tvar _StoreMethods = __webpack_require__(12);\n\t\n\tvar StoreMethods = _interopRequireWildcard(_StoreMethods);\n\t\n\tvar _joins = __webpack_require__(7);\n\t\n\tvar _utils = __webpack_require__(5);\n\t\n\tvar _ = _interopRequireWildcard(_utils);\n\t\n\tvar _createAction = __webpack_require__(14);\n\t\n\tvar _createStore = __webpack_require__(8);\n\t\n\tvar _Keep = __webpack_require__(9);\n\t\n\tvar __keep = _interopRequireWildcard(_Keep);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar version = {\n\t    \"reflux-core\": \"1.0.0\"\n\t};\n\t\n\tvar joinTrailing = (0, _joins.staticJoinCreator)(\"last\");\n\tvar all = joinTrailing; // Reflux.all alias for backward compatibility\n\tvar joinLeading = (0, _joins.staticJoinCreator)(\"first\");\n\tvar joinStrict = (0, _joins.staticJoinCreator)(\"strict\");\n\tvar joinConcat = (0, _joins.staticJoinCreator)(\"all\");\n\t\n\tvar utils = _;\n\t\n\t\n\t/**\r\n\t * Convenience function for creating a set of actions\r\n\t *\r\n\t * @param definitions the definitions for the actions to be created\r\n\t * @returns an object with actions of corresponding action names\r\n\t */\n\tvar createActions = function () {\n\t    var reducer = function reducer(definitions, actions) {\n\t        Object.keys(definitions).forEach(function (actionName) {\n\t            var val = definitions[actionName];\n\t            actions[actionName] = (0, _createAction.createAction)(val);\n\t        });\n\t    };\n\t\n\t    return function (definitions) {\n\t        var actions = {};\n\t        if (definitions instanceof Array) {\n\t            definitions.forEach(function (val) {\n\t                if (_.isObject(val)) {\n\t                    reducer(val, actions);\n\t                } else {\n\t                    actions[val] = (0, _createAction.createAction)(val);\n\t                }\n\t            });\n\t        } else {\n\t            reducer(definitions, actions);\n\t        }\n\t        return actions;\n\t    };\n\t}();\n\t\n\t/**\r\n\t * Sets the eventmitter that Reflux uses\r\n\t */\n\tfunction setEventEmitter(ctx) {\n\t    _.EventEmitter = ctx;\n\t}\n\t\n\t/**\r\n\t * Sets the method used for deferring actions and stores\r\n\t */\n\tfunction nextTick(nextTick) {\n\t    _.nextTick = nextTick;\n\t}\n\t\n\tfunction use(pluginCb) {\n\t    pluginCb(this);\n\t}\n\t\n\t/**\r\n\t * Provides the set of created actions and stores for introspection\r\n\t */\n\t/*eslint-disable no-underscore-dangle*/\n\t\n\t\n\t// export in format that supports syntax: var Reflux = require('reflux-core');\n\texports.version = version;\n\texports.ActionMethods = ActionMethods;\n\texports.ListenerMethods = ListenerMethods;\n\texports.PublisherMethods = PublisherMethods;\n\texports.StoreMethods = StoreMethods;\n\texports.utils = utils;\n\texports.createAction = _createAction.createAction;\n\texports.createStore = _createStore.createStore;\n\texports.createActions = createActions;\n\texports.setEventEmitter = setEventEmitter;\n\texports.nextTick = nextTick;\n\texports.use = use;\n\texports.joinTrailing = joinTrailing;\n\texports.all = all;\n\texports.joinLeading = joinLeading;\n\texports.joinStrict = joinStrict;\n\texports.joinConcat = joinConcat;\n\texports.__keep = __keep;\n\t/*eslint-enable no-underscore-dangle*/\n\t\n\t// export in format that supports syntax: import Reflux from 'reflux-core';\n\t\n\tObject.defineProperty(exports, \"default\", {\n\t    get: function get() {\n\t        return exports;\n\t    }\n\t});\n\t\n\t/**\r\n\t * Warn if Function.prototype.bind not available\r\n\t */\n\tif (!Function.prototype.bind) {\n\t    console.error(\"Function.prototype.bind not available. \" + \"ES5 shim required. \" + \"https://github.com/spoike/refluxjs#es5\");\n\t}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.joinStrict = exports.joinConcat = exports.joinLeading = exports.joinTrailing = exports.fetchInitialState = exports.stopListeningToAll = exports.stopListeningTo = exports.listenTo = exports.validateListening = exports.listenToMany = exports.hasListener = undefined;\n\t\n\tvar _utils = __webpack_require__(5);\n\t\n\tvar _ = _interopRequireWildcard(_utils);\n\t\n\tvar _joins = __webpack_require__(7);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\t/**\r\n\t * Extract child listenables from a parent from their\r\n\t * children property and return them in a keyed Object\r\n\t *\r\n\t * @param {Object} listenable The parent listenable\r\n\t */\n\tvar mapChildListenables = function mapChildListenables(listenable) {\n\t    var i = 0,\n\t        children = {},\n\t        childName;\n\t    for (; i < (listenable.children || []).length; ++i) {\n\t        childName = listenable.children[i];\n\t        if (listenable[childName]) {\n\t            children[childName] = listenable[childName];\n\t        }\n\t    }\n\t    return children;\n\t};\n\t\n\t/**\r\n\t * Make a flat dictionary of all listenables including their\r\n\t * possible children (recursively), concatenating names in camelCase.\r\n\t *\r\n\t * @param {Object} listenables The top-level listenables\r\n\t */\n\tvar flattenListenables = function flattenListenables(listenables) {\n\t    var flattened = {};\n\t    for (var key in listenables) {\n\t        var listenable = listenables[key];\n\t        var childMap = mapChildListenables(listenable);\n\t\n\t        // recursively flatten children\n\t        var children = flattenListenables(childMap);\n\t\n\t        // add the primary listenable and chilren\n\t        flattened[key] = listenable;\n\t        for (var childKey in children) {\n\t            var childListenable = children[childKey];\n\t            flattened[key + _.capitalize(childKey)] = childListenable;\n\t        }\n\t    }\n\t\n\t    return flattened;\n\t};\n\t\n\t/**\r\n\t * An internal utility function used by `validateListening`\r\n\t *\r\n\t * @param {Action|Store} listenable The listenable we want to search for\r\n\t * @returns {Boolean} The result of a recursive search among `this.subscriptions`\r\n\t */\n\tvar hasListener = exports.hasListener = function hasListener(listenable) {\n\t    var i = 0,\n\t        j,\n\t        listener,\n\t        listenables;\n\t    for (; i < (this.subscriptions || []).length; ++i) {\n\t        listenables = [].concat(this.subscriptions[i].listenable);\n\t        for (j = 0; j < listenables.length; j++) {\n\t            listener = listenables[j];\n\t            if (listener === listenable || listener.hasListener && listener.hasListener(listenable)) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t    return false;\n\t};\n\t\n\t/**\r\n\t * A convenience method that listens to all listenables in the given object.\r\n\t *\r\n\t * @param {Object} listenables An object of listenables. Keys will be used as callback method names.\r\n\t */\n\tvar listenToMany = exports.listenToMany = function listenToMany(listenables) {\n\t    var allListenables = flattenListenables(listenables);\n\t    for (var key in allListenables) {\n\t        var cbname = _.callbackName(key),\n\t            localname = this[cbname] ? cbname : this[key] ? key : undefined;\n\t        if (localname) {\n\t            this.listenTo(allListenables[key], localname, this[cbname + \"Default\"] || this[localname + \"Default\"] || localname);\n\t        }\n\t    }\n\t};\n\t\n\t/**\r\n\t * Checks if the current context can listen to the supplied listenable\r\n\t *\r\n\t * @param {Action|Store} listenable An Action or Store that should be\r\n\t *  listened to.\r\n\t * @returns {String|Undefined} An error message, or undefined if there was no problem.\r\n\t */\n\tvar validateListening = exports.validateListening = function validateListening(listenable) {\n\t    if (listenable === this) {\n\t        return \"Listener is not able to listen to itself\";\n\t    }\n\t    if (!_.isFunction(listenable.listen)) {\n\t        return listenable + \" is missing a listen method\";\n\t    }\n\t    if (listenable.hasListener && listenable.hasListener(this)) {\n\t        return \"Listener cannot listen to this listenable because of circular loop\";\n\t    }\n\t};\n\t\n\t/**\r\n\t * Sets up a subscription to the given listenable for the context object\r\n\t *\r\n\t * @param {Action|Store} listenable An Action or Store that should be\r\n\t *  listened to.\r\n\t * @param {Function|String} callback The callback to register as event handler\r\n\t * @param {Function|String} defaultCallback The callback to register as default handler\r\n\t * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to\r\n\t */\n\tvar listenTo = exports.listenTo = function listenTo(listenable, callback, defaultCallback) {\n\t    var desub,\n\t        unsubscriber,\n\t        subscriptionobj,\n\t        subs = this.subscriptions = this.subscriptions || [];\n\t    _.throwIf(this.validateListening(listenable));\n\t    this.fetchInitialState(listenable, defaultCallback);\n\t    desub = listenable.listen(this[callback] || callback, this);\n\t    unsubscriber = function unsubscriber() {\n\t        var index = subs.indexOf(subscriptionobj);\n\t        _.throwIf(index === -1, \"Tried to remove listen already gone from subscriptions list!\");\n\t        subs.splice(index, 1);\n\t        desub();\n\t    };\n\t    subscriptionobj = {\n\t        stop: unsubscriber,\n\t        listenable: listenable\n\t    };\n\t    subs.push(subscriptionobj);\n\t    return subscriptionobj;\n\t};\n\t\n\t/**\r\n\t * Stops listening to a single listenable\r\n\t *\r\n\t * @param {Action|Store} listenable The action or store we no longer want to listen to\r\n\t * @returns {Boolean} True if a subscription was found and removed, otherwise false.\r\n\t */\n\tvar stopListeningTo = exports.stopListeningTo = function stopListeningTo(listenable) {\n\t    var sub,\n\t        i = 0,\n\t        subs = this.subscriptions || [];\n\t    for (; i < subs.length; i++) {\n\t        sub = subs[i];\n\t        if (sub.listenable === listenable) {\n\t            sub.stop();\n\t            _.throwIf(subs.indexOf(sub) !== -1, \"Failed to remove listen from subscriptions list!\");\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t};\n\t\n\t/**\r\n\t * Stops all subscriptions and empties subscriptions array\r\n\t */\n\tvar stopListeningToAll = exports.stopListeningToAll = function stopListeningToAll() {\n\t    var remaining,\n\t        subs = this.subscriptions || [];\n\t    while (remaining = subs.length) {\n\t        subs[0].stop();\n\t        _.throwIf(subs.length !== remaining - 1, \"Failed to remove listen from subscriptions list!\");\n\t    }\n\t};\n\t\n\t/**\r\n\t * Used in `listenTo`. Fetches initial data from a publisher if it has a `getInitialState` method.\r\n\t * @param {Action|Store} listenable The publisher we want to get initial state from\r\n\t * @param {Function|String} defaultCallback The method to receive the data\r\n\t */\n\tvar fetchInitialState = exports.fetchInitialState = function fetchInitialState(listenable, defaultCallback) {\n\t    defaultCallback = defaultCallback && this[defaultCallback] || defaultCallback;\n\t    var me = this;\n\t    if (_.isFunction(defaultCallback) && _.isFunction(listenable.getInitialState)) {\n\t        var data = listenable.getInitialState();\n\t        if (data && _.isFunction(data.then)) {\n\t            data.then(function () {\n\t                defaultCallback.apply(me, arguments);\n\t            });\n\t        } else {\n\t            defaultCallback.call(this, data);\n\t        }\n\t    }\n\t};\n\t\n\t/**\r\n\t * The callback will be called once all listenables have triggered at least once.\r\n\t * It will be invoked with the last emission from each listenable.\r\n\t * @param {...Publishers} publishers Publishers that should be tracked.\r\n\t * @param {Function|String} callback The method to call when all publishers have emitted\r\n\t * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n\t */\n\tvar joinTrailing = exports.joinTrailing = (0, _joins.instanceJoinCreator)(\"last\");\n\t\n\t/**\r\n\t * The callback will be called once all listenables have triggered at least once.\r\n\t * It will be invoked with the first emission from each listenable.\r\n\t * @param {...Publishers} publishers Publishers that should be tracked.\r\n\t * @param {Function|String} callback The method to call when all publishers have emitted\r\n\t * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n\t */\n\tvar joinLeading = exports.joinLeading = (0, _joins.instanceJoinCreator)(\"first\");\n\t\n\t/**\r\n\t * The callback will be called once all listenables have triggered at least once.\r\n\t * It will be invoked with all emission from each listenable.\r\n\t * @param {...Publishers} publishers Publishers that should be tracked.\r\n\t * @param {Function|String} callback The method to call when all publishers have emitted\r\n\t * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n\t */\n\tvar joinConcat = exports.joinConcat = (0, _joins.instanceJoinCreator)(\"all\");\n\t\n\t/**\r\n\t * The callback will be called once all listenables have triggered.\r\n\t * If a callback triggers twice before that happens, an error is thrown.\r\n\t * @param {...Publishers} publishers Publishers that should be tracked.\r\n\t * @param {Function|String} callback The method to call when all publishers have emitted\r\n\t * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n\t */\n\tvar joinStrict = exports.joinStrict = (0, _joins.instanceJoinCreator)(\"strict\");\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\texports.capitalize = capitalize;\n\texports.callbackName = callbackName;\n\texports.isObject = isObject;\n\texports.extend = extend;\n\texports.isFunction = isFunction;\n\texports.nextTick = nextTick;\n\texports.object = object;\n\texports.isArguments = isArguments;\n\texports.throwIf = throwIf;\n\tfunction capitalize(string) {\n\t    return string.charAt(0).toUpperCase() + string.slice(1);\n\t}\n\t\n\tfunction callbackName(string, prefix) {\n\t    prefix = prefix || \"on\";\n\t    return prefix + exports.capitalize(string);\n\t}\n\t\n\t/*\r\n\t * isObject, extend, isFunction, isArguments are taken from underscore/lodash in\r\n\t * order to remove the dependency\r\n\t */\n\tfunction isObject(obj) {\n\t    var type = typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t    return type === \"function\" || type === \"object\" && !!obj;\n\t}\n\t\n\tfunction extend(obj) {\n\t    if (!isObject(obj)) {\n\t        return obj;\n\t    }\n\t    var source, keys, prop;\n\t    for (var i = 1, length = arguments.length; i < length; i++) {\n\t        source = arguments[i];\n\t        keys = Object.keys(source);\n\t        for (var j = 0; j < keys.length; j++) {\n\t            prop = keys[j];\n\t            if (Object.getOwnPropertyDescriptor && Object.defineProperty) {\n\t                var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\n\t                Object.defineProperty(obj, prop, propertyDescriptor);\n\t            } else {\n\t                obj[prop] = source[prop];\n\t            }\n\t        }\n\t    }\n\t    return obj;\n\t}\n\t\n\tfunction isFunction(value) {\n\t    return typeof value === \"function\";\n\t}\n\t\n\texports.EventEmitter = __webpack_require__(6);\n\t\n\tfunction nextTick(callback) {\n\t    setTimeout(callback, 0);\n\t}\n\t\n\tfunction object(keys, vals) {\n\t    var o = {},\n\t        i = 0;\n\t    for (; i < keys.length; i++) {\n\t        o[keys[i]] = vals[i];\n\t    }\n\t    return o;\n\t}\n\t\n\tfunction isArguments(value) {\n\t    return (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" && \"callee\" in value && typeof value.length === \"number\";\n\t}\n\t\n\tfunction throwIf(val, msg) {\n\t    if (val) {\n\t        throw Error(msg || val);\n\t    }\n\t}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar has = Object.prototype.hasOwnProperty;\n\t\n\t//\n\t// We store our EE objects in a plain object whose properties are event names.\n\t// If `Object.create(null)` is not supported we prefix the event names with a\n\t// `~` to make sure that the built-in object properties are not overridden or\n\t// used as an attack vector.\n\t// We also assume that `Object.create(null)` is available when the event name\n\t// is an ES6 Symbol.\n\t//\n\tvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\t\n\t/**\n\t * Representation of a single EventEmitter function.\n\t *\n\t * @param {Function} fn Event handler to be called.\n\t * @param {Mixed} context Context for function execution.\n\t * @param {Boolean} [once=false] Only emit once\n\t * @api private\n\t */\n\tfunction EE(fn, context, once) {\n\t  this.fn = fn;\n\t  this.context = context;\n\t  this.once = once || false;\n\t}\n\t\n\t/**\n\t * Minimal EventEmitter interface that is molded against the Node.js\n\t * EventEmitter interface.\n\t *\n\t * @constructor\n\t * @api public\n\t */\n\tfunction EventEmitter() { /* Nothing to set */ }\n\t\n\t/**\n\t * Hold the assigned EventEmitters by name.\n\t *\n\t * @type {Object}\n\t * @private\n\t */\n\tEventEmitter.prototype._events = undefined;\n\t\n\t/**\n\t * Return an array listing the events for which the emitter has registered\n\t * listeners.\n\t *\n\t * @returns {Array}\n\t * @api public\n\t */\n\tEventEmitter.prototype.eventNames = function eventNames() {\n\t  var events = this._events\n\t    , names = []\n\t    , name;\n\t\n\t  if (!events) return names;\n\t\n\t  for (name in events) {\n\t    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n\t  }\n\t\n\t  if (Object.getOwnPropertySymbols) {\n\t    return names.concat(Object.getOwnPropertySymbols(events));\n\t  }\n\t\n\t  return names;\n\t};\n\t\n\t/**\n\t * Return a list of assigned event listeners.\n\t *\n\t * @param {String} event The events that should be listed.\n\t * @param {Boolean} exists We only need to know if there are listeners.\n\t * @returns {Array|Boolean}\n\t * @api public\n\t */\n\tEventEmitter.prototype.listeners = function listeners(event, exists) {\n\t  var evt = prefix ? prefix + event : event\n\t    , available = this._events && this._events[evt];\n\t\n\t  if (exists) return !!available;\n\t  if (!available) return [];\n\t  if (available.fn) return [available.fn];\n\t\n\t  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n\t    ee[i] = available[i].fn;\n\t  }\n\t\n\t  return ee;\n\t};\n\t\n\t/**\n\t * Emit an event to all registered event listeners.\n\t *\n\t * @param {String} event The name of the event.\n\t * @returns {Boolean} Indication if we've emitted an event.\n\t * @api public\n\t */\n\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n\t  var evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events || !this._events[evt]) return false;\n\t\n\t  var listeners = this._events[evt]\n\t    , len = arguments.length\n\t    , args\n\t    , i;\n\t\n\t  if ('function' === typeof listeners.fn) {\n\t    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\t\n\t    switch (len) {\n\t      case 1: return listeners.fn.call(listeners.context), true;\n\t      case 2: return listeners.fn.call(listeners.context, a1), true;\n\t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n\t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n\t    }\n\t\n\t    for (i = 1, args = new Array(len -1); i < len; i++) {\n\t      args[i - 1] = arguments[i];\n\t    }\n\t\n\t    listeners.fn.apply(listeners.context, args);\n\t  } else {\n\t    var length = listeners.length\n\t      , j;\n\t\n\t    for (i = 0; i < length; i++) {\n\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\t\n\t      switch (len) {\n\t        case 1: listeners[i].fn.call(listeners[i].context); break;\n\t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n\t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n\t        default:\n\t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n\t            args[j - 1] = arguments[j];\n\t          }\n\t\n\t          listeners[i].fn.apply(listeners[i].context, args);\n\t      }\n\t    }\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t/**\n\t * Register a new EventListener for the given event.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Function} fn Callback function.\n\t * @param {Mixed} [context=this] The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.on = function on(event, fn, context) {\n\t  var listener = new EE(fn, context || this)\n\t    , evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events) this._events = prefix ? {} : Object.create(null);\n\t  if (!this._events[evt]) this._events[evt] = listener;\n\t  else {\n\t    if (!this._events[evt].fn) this._events[evt].push(listener);\n\t    else this._events[evt] = [\n\t      this._events[evt], listener\n\t    ];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add an EventListener that's only called once.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Function} fn Callback function.\n\t * @param {Mixed} [context=this] The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.once = function once(event, fn, context) {\n\t  var listener = new EE(fn, context || this, true)\n\t    , evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events) this._events = prefix ? {} : Object.create(null);\n\t  if (!this._events[evt]) this._events[evt] = listener;\n\t  else {\n\t    if (!this._events[evt].fn) this._events[evt].push(listener);\n\t    else this._events[evt] = [\n\t      this._events[evt], listener\n\t    ];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove event listeners.\n\t *\n\t * @param {String} event The event we want to remove.\n\t * @param {Function} fn The listener that we need to find.\n\t * @param {Mixed} context Only remove listeners matching this context.\n\t * @param {Boolean} once Only remove once listeners.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n\t  var evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events || !this._events[evt]) return this;\n\t\n\t  var listeners = this._events[evt]\n\t    , events = [];\n\t\n\t  if (fn) {\n\t    if (listeners.fn) {\n\t      if (\n\t           listeners.fn !== fn\n\t        || (once && !listeners.once)\n\t        || (context && listeners.context !== context)\n\t      ) {\n\t        events.push(listeners);\n\t      }\n\t    } else {\n\t      for (var i = 0, length = listeners.length; i < length; i++) {\n\t        if (\n\t             listeners[i].fn !== fn\n\t          || (once && !listeners[i].once)\n\t          || (context && listeners[i].context !== context)\n\t        ) {\n\t          events.push(listeners[i]);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  //\n\t  // Reset the array, or remove it completely if we have no more listeners.\n\t  //\n\t  if (events.length) {\n\t    this._events[evt] = events.length === 1 ? events[0] : events;\n\t  } else {\n\t    delete this._events[evt];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove all listeners or only the listeners for the specified event.\n\t *\n\t * @param {String} event The event want to remove all listeners for.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n\t  if (!this._events) return this;\n\t\n\t  if (event) delete this._events[prefix ? prefix + event : event];\n\t  else this._events = prefix ? {} : Object.create(null);\n\t\n\t  return this;\n\t};\n\t\n\t//\n\t// Alias methods names because people roll like that.\n\t//\n\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t//\n\t// This function doesn't apply anymore.\n\t//\n\tEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n\t  return this;\n\t};\n\t\n\t//\n\t// Expose the prefix.\n\t//\n\tEventEmitter.prefixed = prefix;\n\t\n\t//\n\t// Expose the module.\n\t//\n\tif (true) {\n\t  module.exports = EventEmitter;\n\t}\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.staticJoinCreator = staticJoinCreator;\n\texports.instanceJoinCreator = instanceJoinCreator;\n\t\n\tvar _createStore = __webpack_require__(8);\n\t\n\tvar _utils = __webpack_require__(5);\n\t\n\tvar _ = _interopRequireWildcard(_utils);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\t/**\r\n\t * Internal module used to create static and instance join methods\r\n\t */\n\t\n\tvar slice = Array.prototype.slice,\n\t    strategyMethodNames = {\n\t    strict: \"joinStrict\",\n\t    first: \"joinLeading\",\n\t    last: \"joinTrailing\",\n\t    all: \"joinConcat\"\n\t};\n\t\n\t/**\r\n\t * Used in `index.js` to create the static join methods\r\n\t * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\r\n\t * @returns {Function} A static function which returns a store with a join listen on the given listenables using the given strategy\r\n\t */\n\tfunction staticJoinCreator(strategy) {\n\t    return function () /* listenables... */{\n\t        var listenables = slice.call(arguments);\n\t        return (0, _createStore.createStore)({\n\t            init: function init() {\n\t                this[strategyMethodNames[strategy]].apply(this, listenables.concat(\"triggerAsync\"));\n\t            }\n\t        });\n\t    };\n\t}\n\t\n\t/**\r\n\t * Used in `ListenerMethods.js` to create the instance join methods\r\n\t * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\r\n\t * @returns {Function} An instance method which sets up a join listen on the given listenables using the given strategy\r\n\t */\n\tfunction instanceJoinCreator(strategy) {\n\t    return function () /* listenables..., callback*/{\n\t        _.throwIf(arguments.length < 2, \"Cannot create a join with less than 2 listenables!\");\n\t        var listenables = slice.call(arguments),\n\t            callback = listenables.pop(),\n\t            numberOfListenables = listenables.length,\n\t            join = {\n\t            numberOfListenables: numberOfListenables,\n\t            callback: this[callback] || callback,\n\t            listener: this,\n\t            strategy: strategy\n\t        },\n\t            i,\n\t            cancels = [],\n\t            subobj;\n\t        for (i = 0; i < numberOfListenables; i++) {\n\t            _.throwIf(this.validateListening(listenables[i]));\n\t        }\n\t        for (i = 0; i < numberOfListenables; i++) {\n\t            cancels.push(listenables[i].listen(newListener(i, join), this));\n\t        }\n\t        reset(join);\n\t        subobj = { listenable: listenables };\n\t        subobj.stop = makeStopper(subobj, cancels, this);\n\t        this.subscriptions = (this.subscriptions || []).concat(subobj);\n\t        return subobj;\n\t    };\n\t}\n\t\n\t// ---- internal join functions ----\n\t\n\tfunction makeStopper(subobj, cancels, context) {\n\t    return function () {\n\t        var i,\n\t            subs = context.subscriptions,\n\t            index = subs ? subs.indexOf(subobj) : -1;\n\t        _.throwIf(index === -1, \"Tried to remove join already gone from subscriptions list!\");\n\t        for (i = 0; i < cancels.length; i++) {\n\t            cancels[i]();\n\t        }\n\t        subs.splice(index, 1);\n\t    };\n\t}\n\t\n\tfunction reset(join) {\n\t    join.listenablesEmitted = new Array(join.numberOfListenables);\n\t    join.args = new Array(join.numberOfListenables);\n\t}\n\t\n\tfunction newListener(i, join) {\n\t    return function () {\n\t        var callargs = slice.call(arguments);\n\t        if (join.listenablesEmitted[i]) {\n\t            switch (join.strategy) {\n\t                case \"strict\":\n\t                    throw new Error(\"Strict join failed because listener triggered twice.\");\n\t                case \"last\":\n\t                    join.args[i] = callargs;break;\n\t                case \"all\":\n\t                    join.args[i].push(callargs);\n\t            }\n\t        } else {\n\t            join.listenablesEmitted[i] = true;\n\t            join.args[i] = join.strategy === \"all\" ? [callargs] : callargs;\n\t        }\n\t        emitIfAllListenablesEmitted(join);\n\t    };\n\t}\n\t\n\tfunction emitIfAllListenablesEmitted(join) {\n\t    for (var i = 0; i < join.numberOfListenables; i++) {\n\t        if (!join.listenablesEmitted[i]) {\n\t            return;\n\t        }\n\t    }\n\t    join.callback.apply(join.listener, join.args);\n\t    reset(join);\n\t}\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.createStore = createStore;\n\t\n\tvar _utils = __webpack_require__(5);\n\t\n\tvar _ = _interopRequireWildcard(_utils);\n\t\n\tvar _Keep = __webpack_require__(9);\n\t\n\tvar Keep = _interopRequireWildcard(_Keep);\n\t\n\tvar _mixer = __webpack_require__(10);\n\t\n\tvar _bindMethods = __webpack_require__(11);\n\t\n\tvar _StoreMethods = __webpack_require__(12);\n\t\n\tvar StoreMethods = _interopRequireWildcard(_StoreMethods);\n\t\n\tvar _PublisherMethods = __webpack_require__(13);\n\t\n\tvar PublisherMethods = _interopRequireWildcard(_PublisherMethods);\n\t\n\tvar _ListenerMethods = __webpack_require__(4);\n\t\n\tvar ListenerMethods = _interopRequireWildcard(_ListenerMethods);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar allowed = { preEmit: 1, shouldEmit: 1 };\n\t\n\t/**\r\n\t * Creates an event emitting Data Store. It is mixed in with functions\r\n\t * from the `ListenerMethods` and `PublisherMethods` mixins. `preEmit`\r\n\t * and `shouldEmit` may be overridden in the definition object.\r\n\t *\r\n\t * @param {Object} definition The data store object definition\r\n\t * @returns {Store} A data store instance\r\n\t */\n\tfunction createStore(definition) {\n\t\n\t    definition = definition || {};\n\t\n\t    for (var a in StoreMethods) {\n\t        if (!allowed[a] && (PublisherMethods[a] || ListenerMethods[a])) {\n\t            throw new Error(\"Cannot override API method \" + a + \" in Reflux.StoreMethods. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.\");\n\t        }\n\t    }\n\t\n\t    for (var d in definition) {\n\t        if (!allowed[d] && (PublisherMethods[d] || ListenerMethods[d])) {\n\t            throw new Error(\"Cannot override API method \" + d + \" in store creation. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.\");\n\t        }\n\t    }\n\t\n\t    definition = (0, _mixer.mix)(definition);\n\t\n\t    function Store() {\n\t        var i = 0,\n\t            arr;\n\t        this.subscriptions = [];\n\t        this.emitter = new _.EventEmitter();\n\t        this.eventLabel = \"change\";\n\t        (0, _bindMethods.bindMethods)(this, definition);\n\t        if (this.init && _.isFunction(this.init)) {\n\t            this.init();\n\t        }\n\t        if (this.listenables) {\n\t            arr = [].concat(this.listenables);\n\t            for (; i < arr.length; i++) {\n\t                this.listenToMany(arr[i]);\n\t            }\n\t        }\n\t    }\n\t\n\t    _.extend(Store.prototype, ListenerMethods, PublisherMethods, StoreMethods, definition);\n\t\n\t    var store = new Store();\n\t    Keep.addStore(store);\n\t\n\t    return store;\n\t}\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\t// this needs to be set to true before Keep.js starts storing, done via useKeep\n\tvar use = false;\n\t\n\tvar createdStores = [];\n\t\n\tvar createdActions = [];\n\t\n\tfunction useKeep() {\n\t\tvar bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\t\n\t\tuse = bool;\n\t}\n\t\n\tfunction addStore(str) {\n\t\tif (use) {\n\t\t\tcreatedStores.push(str);\n\t\t}\n\t}\n\t\n\tfunction addAction(act) {\n\t\tif (use) {\n\t\t\tcreatedActions.push(act);\n\t\t}\n\t}\n\t\n\tfunction reset() {\n\t\twhile (createdStores.length) {\n\t\t\tcreatedStores.pop();\n\t\t}\n\t\twhile (createdActions.length) {\n\t\t\tcreatedActions.pop();\n\t\t}\n\t}\n\t\n\texports.useKeep = useKeep;\n\texports.addStore = addStore;\n\texports.addAction = addAction;\n\texports.createdStores = createdStores;\n\texports.createdActions = createdActions;\n\texports.reset = reset;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.mix = mix;\n\t\n\tvar _utils = __webpack_require__(5);\n\t\n\tvar _ = _interopRequireWildcard(_utils);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction mix(def) {\n\t    var composed = {\n\t        init: [],\n\t        preEmit: [],\n\t        shouldEmit: []\n\t    };\n\t\n\t    var updated = function mixDef(mixin) {\n\t        var mixed = {};\n\t        if (mixin.mixins) {\n\t            mixin.mixins.forEach(function (subMixin) {\n\t                _.extend(mixed, mixDef(subMixin));\n\t            });\n\t        }\n\t        _.extend(mixed, mixin);\n\t        Object.keys(composed).forEach(function (composable) {\n\t            if (mixin.hasOwnProperty(composable)) {\n\t                composed[composable].push(mixin[composable]);\n\t            }\n\t        });\n\t        return mixed;\n\t    }(def);\n\t\n\t    if (composed.init.length > 1) {\n\t        updated.init = function () {\n\t            var args = arguments;\n\t            composed.init.forEach(function (init) {\n\t                init.apply(this, args);\n\t            }, this);\n\t        };\n\t    }\n\t    if (composed.preEmit.length > 1) {\n\t        updated.preEmit = function () {\n\t            return composed.preEmit.reduce(function (args, preEmit) {\n\t                var newValue = preEmit.apply(this, args);\n\t                return newValue === undefined ? args : [newValue];\n\t            }.bind(this), arguments);\n\t        };\n\t    }\n\t    if (composed.shouldEmit.length > 1) {\n\t        updated.shouldEmit = function () {\n\t            var args = arguments;\n\t            return !composed.shouldEmit.some(function (shouldEmit) {\n\t                return !shouldEmit.apply(this, args);\n\t            }, this);\n\t        };\n\t    }\n\t    Object.keys(composed).forEach(function (composable) {\n\t        if (composed[composable].length === 1) {\n\t            updated[composable] = composed[composable][0];\n\t        }\n\t    });\n\t\n\t    return updated;\n\t}\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.bindMethods = bindMethods;\n\tfunction bindMethods(store, definition) {\n\t    for (var name in definition) {\n\t        if (Object.getOwnPropertyDescriptor && Object.defineProperty) {\n\t            var propertyDescriptor = Object.getOwnPropertyDescriptor(definition, name);\n\t\n\t            if (!propertyDescriptor.value || typeof propertyDescriptor.value !== \"function\" || !definition.hasOwnProperty(name)) {\n\t                continue;\n\t            }\n\t\n\t            store[name] = definition[name].bind(store);\n\t        } else {\n\t            var property = definition[name];\n\t\n\t            if (typeof property !== \"function\" || !definition.hasOwnProperty(name)) {\n\t                continue;\n\t            }\n\t\n\t            store[name] = property.bind(store);\n\t        }\n\t    }\n\t\n\t    return store;\n\t}\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.deferWith = exports.triggerAsync = exports.trigger = exports.listen = exports.shouldEmit = exports.preEmit = undefined;\n\t\n\tvar _utils = __webpack_require__(5);\n\t\n\tvar _ = _interopRequireWildcard(_utils);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\t/**\r\n\t * A module of methods for object that you want to be able to listen to.\r\n\t * This module is consumed by `createStore` and `createAction`\r\n\t */\n\t\n\t/**\r\n\t * Hook used by the publisher that is invoked before emitting\r\n\t * and before `shouldEmit`. The arguments are the ones that the action\r\n\t * is invoked with. If this function returns something other than\r\n\t * undefined, that will be passed on as arguments for shouldEmit and\r\n\t * emission.\r\n\t */\n\tvar preEmit = exports.preEmit = function preEmit() {};\n\t\n\t/**\r\n\t * Hook used by the publisher after `preEmit` to determine if the\r\n\t * event should be emitted with given arguments. This may be overridden\r\n\t * in your application, default implementation always returns true.\r\n\t *\r\n\t * @returns {Boolean} true if event should be emitted\r\n\t */\n\tvar shouldEmit = exports.shouldEmit = function shouldEmit() {\n\t    return true;\n\t};\n\t\n\t/**\r\n\t * Subscribes the given callback for action triggered\r\n\t *\r\n\t * @param {Function} callback The callback to register as event handler\r\n\t * @param {Mixed} [optional] bindContext The context to bind the callback with\r\n\t * @returns {Function} Callback that unsubscribes the registered event handler\r\n\t */\n\tvar listen = exports.listen = function listen(callback, bindContext) {\n\t    bindContext = bindContext || this;\n\t    var eventHandler = function eventHandler(args) {\n\t        if (aborted) {\n\t            return;\n\t        }\n\t        callback.apply(bindContext, args);\n\t    },\n\t        me = this,\n\t        aborted = false;\n\t    this.emitter.addListener(this.eventLabel, eventHandler);\n\t    return function () {\n\t        aborted = true;\n\t        me.emitter.removeListener(me.eventLabel, eventHandler);\n\t    };\n\t};\n\t\n\t/**\r\n\t * Publishes an event using `this.emitter` (if `shouldEmit` agrees)\r\n\t */\n\tvar trigger = exports.trigger = function trigger() {\n\t    var args = arguments,\n\t        pre = this.preEmit.apply(this, args);\n\t    args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);\n\t    if (this.shouldEmit.apply(this, args)) {\n\t        this.emitter.emit(this.eventLabel, args);\n\t    }\n\t};\n\t\n\t/**\r\n\t * Tries to publish the event on the next tick\r\n\t */\n\tvar triggerAsync = exports.triggerAsync = function triggerAsync() {\n\t    var args = arguments,\n\t        me = this;\n\t    _.nextTick(function () {\n\t        me.trigger.apply(me, args);\n\t    });\n\t};\n\t\n\t/**\r\n\t * Wraps the trigger mechanism with a deferral function.\r\n\t *\r\n\t * @param {Function} callback the deferral function,\r\n\t *        first argument is the resolving function and the\r\n\t *        rest are the arguments provided from the previous\r\n\t *        trigger invocation\r\n\t */\n\tvar deferWith = exports.deferWith = function deferWith(callback) {\n\t    var oldTrigger = this.trigger,\n\t        ctx = this,\n\t        resolver = function resolver() {\n\t        oldTrigger.apply(ctx, arguments);\n\t    };\n\t    this.trigger = function () {\n\t        callback.apply(ctx, [resolver].concat([].splice.call(arguments, 0)));\n\t    };\n\t};\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.createAction = createAction;\n\t\n\tvar _utils = __webpack_require__(5);\n\t\n\tvar _ = _interopRequireWildcard(_utils);\n\t\n\tvar _ActionMethods = __webpack_require__(3);\n\t\n\tvar ActionMethods = _interopRequireWildcard(_ActionMethods);\n\t\n\tvar _PublisherMethods = __webpack_require__(13);\n\t\n\tvar PublisherMethods = _interopRequireWildcard(_PublisherMethods);\n\t\n\tvar _Keep = __webpack_require__(9);\n\t\n\tvar Keep = _interopRequireWildcard(_Keep);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar allowed = { preEmit: 1, shouldEmit: 1 };\n\t\n\t/**\r\n\t * Creates an action functor object. It is mixed in with functions\r\n\t * from the `PublisherMethods` mixin. `preEmit` and `shouldEmit` may\r\n\t * be overridden in the definition object.\r\n\t *\r\n\t * @param {Object} definition The action object definition\r\n\t */\n\tfunction createAction(definition) {\n\t\n\t    definition = definition || {};\n\t    if (!_.isObject(definition)) {\n\t        definition = { actionName: definition };\n\t    }\n\t\n\t    for (var a in ActionMethods) {\n\t        if (!allowed[a] && PublisherMethods[a]) {\n\t            throw new Error(\"Cannot override API method \" + a + \" in Reflux.ActionMethods. Use another method name or override it on Reflux.PublisherMethods instead.\");\n\t        }\n\t    }\n\t\n\t    for (var d in definition) {\n\t        if (!allowed[d] && PublisherMethods[d]) {\n\t            throw new Error(\"Cannot override API method \" + d + \" in action creation. Use another method name or override it on Reflux.PublisherMethods instead.\");\n\t        }\n\t    }\n\t\n\t    definition.children = definition.children || [];\n\t    if (definition.asyncResult) {\n\t        definition.children = definition.children.concat([\"completed\", \"failed\"]);\n\t    }\n\t\n\t    var i = 0,\n\t        childActions = {};\n\t    for (; i < definition.children.length; i++) {\n\t        var chDef = definition.children[i];\n\t        var chName = typeof chDef === \"string\" ? chDef : chDef.actionName;\n\t        childActions[chName] = createAction(chDef);\n\t    }\n\t\n\t    var context = _.extend({\n\t        eventLabel: \"action\",\n\t        emitter: new _.EventEmitter(),\n\t        _isAction: true\n\t    }, PublisherMethods, ActionMethods, definition);\n\t\n\t    var functor = function functor() {\n\t        var hasChildActions = false;\n\t        /* eslint no-unused-vars:0 */\n\t        for (var ignore in functor.childActions) {\n\t            hasChildActions = true;break;\n\t        }\n\t        var async = !functor.sync && typeof functor.sync !== \"undefined\" || hasChildActions;\n\t        var triggerType = async ? \"triggerAsync\" : \"trigger\";\n\t        return functor[triggerType].apply(functor, arguments);\n\t    };\n\t\n\t    _.extend(functor, childActions, context);\n\t\n\t    Keep.addAction(functor);\n\t\n\t    return functor;\n\t}\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar ListenerMethods = __webpack_require__(4),\r\n\t    ListenerMixin = __webpack_require__(16),\r\n\t    _ = __webpack_require__(5);\r\n\t\r\n\tmodule.exports = function(listenable, key) {\r\n\t\r\n\t    _.throwIf(typeof(key) === 'undefined', 'Reflux.connect() requires a key.');\r\n\t\r\n\t    return {\r\n\t        getInitialState: function() {\r\n\t            if (!_.isFunction(listenable.getInitialState)) {\r\n\t                return {};\r\n\t            }\r\n\t\r\n\t            return _.object([key],[listenable.getInitialState()]);\r\n\t        },\r\n\t        componentDidMount: function() {\r\n\t            var me = this;\r\n\t\r\n\t            _.extend(me, ListenerMethods);\r\n\t\r\n\t            this.listenTo(listenable, function(v) {\r\n\t                me.setState(_.object([key],[v]));\r\n\t            });\r\n\t        },\r\n\t        componentWillUnmount: ListenerMixin.componentWillUnmount\r\n\t    };\r\n\t};\r\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _ = __webpack_require__(5),\r\n\t    ListenerMethods = __webpack_require__(4);\r\n\t\r\n\t/**\r\n\t * A module meant to be consumed as a mixin by a React component. Supplies the methods from\r\n\t * `ListenerMethods` mixin and takes care of teardown of subscriptions.\r\n\t * Note that if you're using the `connect` mixin you don't need this mixin, as connect will\r\n\t * import everything this mixin contains!\r\n\t */\r\n\tmodule.exports = _.extend({\r\n\t\r\n\t    /**\r\n\t     * Cleans up all listener previously registered.\r\n\t     */\r\n\t    componentWillUnmount: ListenerMethods.stopListeningToAll\r\n\t\r\n\t}, ListenerMethods);\r\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar ListenerMethods = __webpack_require__(4),\r\n\t    ListenerMixin = __webpack_require__(16),\r\n\t    _ = __webpack_require__(5);\r\n\t\r\n\tmodule.exports = function(listenable, key, filterFunc) {\r\n\t\r\n\t    _.throwIf(_.isFunction(key), 'Reflux.connectFilter() requires a key.');\r\n\t\r\n\t    return {\r\n\t        getInitialState: function() {\r\n\t            if (!_.isFunction(listenable.getInitialState)) {\r\n\t                return {};\r\n\t            }\r\n\t\r\n\t            // Filter initial payload from store.\r\n\t            var result = filterFunc.call(this, listenable.getInitialState());\r\n\t            if (typeof(result) !== 'undefined') {\r\n\t                return _.object([key], [result]);\r\n\t            } else {\r\n\t                return {};\r\n\t            }\r\n\t        },\r\n\t        componentDidMount: function() {\r\n\t            var me = this;\r\n\t\r\n\t            _.extend(this, ListenerMethods);\r\n\t\r\n\t            this.listenTo(listenable, function(value) {\r\n\t                var result = filterFunc.call(me, value);\r\n\t                me.setState(_.object([key], [result]));\r\n\t            });\r\n\t        },\r\n\t        componentWillUnmount: ListenerMixin.componentWillUnmount\r\n\t    };\r\n\t};\r\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar ListenerMethods = __webpack_require__(4);\r\n\t\r\n\t/**\r\n\t * A mixin factory for a React component. Meant as a more convenient way of using the `ListenerMixin`,\r\n\t * without having to manually set listeners in the `componentDidMount` method.\r\n\t *\r\n\t * @param {Action|Store} listenable An Action or Store that should be\r\n\t *  listened to.\r\n\t * @param {Function|String} callback The callback to register as event handler\r\n\t * @param {Function|String} defaultCallback The callback to register as default handler\r\n\t * @returns {Object} An object to be used as a mixin, which sets up the listener for the given listenable.\r\n\t */\r\n\tmodule.exports = function(listenable,callback,initial){\r\n\t    return {\r\n\t        /**\r\n\t         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`\r\n\t         * and then make the call to `listenTo` with the arguments provided to the factory function\r\n\t         */\r\n\t        componentDidMount: function() {\r\n\t            for(var m in ListenerMethods){\r\n\t                if (this[m] !== ListenerMethods[m]){\r\n\t                    if (this[m]){\r\n\t                        throw \"Can't have other property '\"+m+\"' when using Reflux.listenTo!\";\r\n\t                    }\r\n\t                    this[m] = ListenerMethods[m];\r\n\t                }\r\n\t            }\r\n\t            this.listenTo(listenable,callback,initial);\r\n\t        },\r\n\t        /**\r\n\t         * Cleans up all listener previously registered.\r\n\t         */\r\n\t        componentWillUnmount: ListenerMethods.stopListeningToAll\r\n\t    };\r\n\t};\r\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar ListenerMethods = __webpack_require__(4);\r\n\t\r\n\t/**\r\n\t * A mixin factory for a React component. Meant as a more convenient way of using the `listenerMixin`,\r\n\t * without having to manually set listeners in the `componentDidMount` method. This version is used\r\n\t * to automatically set up a `listenToMany` call.\r\n\t *\r\n\t * @param {Object} listenables An object of listenables\r\n\t * @returns {Object} An object to be used as a mixin, which sets up the listeners for the given listenables.\r\n\t */\r\n\tmodule.exports = function(listenables){\r\n\t    return {\r\n\t        /**\r\n\t         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`\r\n\t         * and then make the call to `listenTo` with the arguments provided to the factory function\r\n\t         */\r\n\t        componentDidMount: function() {\r\n\t            for(var m in ListenerMethods){\r\n\t                if (this[m] !== ListenerMethods[m]){\r\n\t                    if (this[m]){\r\n\t                        throw \"Can't have other property '\"+m+\"' when using Reflux.listenToMany!\";\r\n\t                    }\r\n\t                    this[m] = ListenerMethods[m];\r\n\t                }\r\n\t            }\r\n\t            this.listenToMany(listenables);\r\n\t        },\r\n\t        /**\r\n\t         * Cleans up all listener previously registered.\r\n\t         */\r\n\t        componentWillUnmount: ListenerMethods.stopListeningToAll\r\n\t    };\r\n\t};\r\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t/* globals React: false */\r\n\t\r\n\tvar Reflux = __webpack_require__(2);\r\n\tReflux.defineReact = __webpack_require__(21);\r\n\t\r\n\t// useful utility for ES6 work, mimics the ability to extend\r\n\tReflux.utils.inherits = function(subClass, superClass) {\r\n\t\tif (typeof superClass !== \"function\" && superClass !== null) {\r\n\t\t\tthrow new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\r\n\t\t}\r\n\t\tsubClass.prototype = Object.create(superClass && superClass.prototype, {\r\n\t\t\tconstructor: {\r\n\t\t\t\tvalue: subClass,\r\n\t\t\t\tenumerable: false,\r\n\t\t\t\twritable: true,\r\n\t\t\t\tconfigurable: true\r\n\t\t\t}\r\n\t\t});\r\n\t\tif (superClass) {\r\n\t\t\tif (Object.setPrototypeOf) {\r\n\t\t\t\tObject.setPrototypeOf(subClass, superClass);\r\n\t\t\t} else {\r\n\t\t\t\t/* jshint proto: true */\r\n\t\t\t\tsubClass.__proto__ = superClass;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t// first try to see if there's a global React var and use it\r\n\tif (typeof React !== 'undefined' && React) {\r\n\t\tReflux.defineReact(React);\r\n\t// otherwise we're gonna resort to 'try' stuff in case of other environments\r\n\t} else {\r\n\t\ttry {\r\n\t\t\tvar R = __webpack_require__(22); // we ignore this in browserify manually (see grunt file), so it's more of a doublecheck for in node\r\n\t\t\tReflux.defineReact(R);\r\n\t\t} catch (e) {}\r\n\t}\r\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* globals React: false */\r\n\t\r\n\tvar Reflux = __webpack_require__(2);\r\n\t\r\n\t/**\r\n\t * Reflux.defineReact function where you can manually supply\r\n\t * the React object in order to create in case Reflux needs to load before\r\n\t * React or there is a modular environment where there won't be a global\r\n\t * React variable.\r\n\t * @note The third param is for internal usage only.\r\n\t */\r\n\tvar _react, _defined = false;\r\n\tfunction defineReact(react, noLongerUsed, extend)\r\n\t{\r\n\t\tvar proto, _extend;\r\n\t\t\r\n\t\t// if no Reflux object is yet available then return and just wait until defineReact is called manually with it\r\n\t\ttry {\r\n\t\t\t_react  = react  || _react  || React;\r\n\t\t\t_extend = extend || _react.Component;\r\n\t\t} catch (e) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t// if Reflux and React aren't present then ignore, wait until they are properly present\r\n\t\t// also ignore if it's been called before UNLESS there's manual extending happening\r\n\t\tif (!_react || !_extend || (_defined && !extend)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t// ----------- BEGIN Reflux.Component ------------\r\n\t\t/**\r\n\t\t * Reflux.Component:\r\n\t\t * An implementation for idiomatic React.js classes that mix with\r\n\t\t * Reflux stores. To utilize extend Reflux.Component instead of\r\n\t\t * React.Component. Then you may hook any Reflux store that has a\r\n\t\t * `this.state` property containing its state values to the component\r\n\t\t * via `this.store` or an Array of Reflux stores via `this.stores` in\r\n\t\t * the component's constructor (similar to how you assign initial state\r\n\t\t * in the constructor in ES6 style React). The default values of the\r\n\t\t * stores will automatically reflect in the component's state, and any\r\n\t\t * further `trigger` calls from that store will update properties passed\r\n\t\t * in the trigger into the component automatically.\r\n\t\t */\r\n\t\tvar RefluxComponent = function(props, context, updater) {\r\n\t\t\t_extend.call(this, props, context, updater);\r\n\t\t};\r\n\t\t\r\n\t\t// equivalent of `extends React.Component` or other class if provided via `extend` param\r\n\t\tReflux.utils.inherits(RefluxComponent, _extend);\r\n\t\t\r\n\t\tproto = RefluxComponent.prototype;\r\n\t\t\r\n\t\t/**\r\n\t\t * this.storeKeys\r\n\t\t * When this is a falsey value (null by default) the component mixes in\r\n\t\t * all properties from the stores attached to it and updates on changes\r\n\t\t * from all of them. When set to an array of string keys it will only\r\n\t\t * utilized state property names of those keys in any store attached. This\r\n\t\t * lets you choose which parts of stores update the component on a component-\r\n\t\t * by-component basis. If using this it is best set in the constructor.\r\n\t\t */\r\n\t\tproto.storeKeys = null;\r\n\t\t\r\n\t\t// on the mounting of the component that is where the store/stores are attached and initialized if needed\r\n\t\tproto.componentWillMount = function () {\r\n\t\t\t// if there is a this.store then simply push it onto the this.stores array or make one if needed\r\n\t\t\tif (this.store) {\r\n\t\t\t\tif (Array.isArray(this.stores)) {\r\n\t\t\t\t\tthis.stores.unshift(this.store);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.stores = [this.store];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (this.stores) {\r\n\t\t\t\tthis.__storeunsubscribes__ = this.__storeunsubscribes__ || [];\r\n\t\t\t\tvar sS = this.setState.bind(this);\r\n\t\t\t\t// this handles the triggering of a store, checking what's updated if proto.storeKeys is utilized\r\n\t\t\t\tvar onStoreTrigger = function(obj){\r\n\t\t\t\t\tvar updateObj = filterByStoreKeys(this.storeKeys, obj);\r\n\t\t\t\t\tif (updateObj) {\r\n\t\t\t\t\t\tsS(updateObj);\r\n\t\t\t\t\t}\r\n\t\t\t\t}.bind(this);\r\n\t\t\t\t// for each store in this.stores...\r\n\t\t\t\tfor (var i = 0, ii = this.stores.length; i < ii; i++) {\r\n\t\t\t\t\tvar str = this.stores[i];\r\n\t\t\t\t\t// if's a function then we know it's a class getting passed, not an instance\r\n\t\t\t\t\tif (typeof str === 'function') {\r\n\t\t\t\t\t\tvar storeId = str.id;\r\n\t\t\t\t\t\t// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so\r\n\t\t\t\t\t\tif (!str.singleton) {\r\n\t\t\t\t\t\t\tstr.singleton = new str();\r\n\t\t\t\t\t\t\tif (storeId) {\r\n\t\t\t\t\t\t\t\tReflux.stores[storeId] = str.singleton;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// before we weren't sure if we were working with an instance or class, so now we know an instance is created set it\r\n\t\t\t\t\t\t// to the variables we were using so that we can just continue on knowing it's the instance we're working with\r\n\t\t\t\t\t\tthis.stores[i] = str = str.singleton;\r\n\t\t\t\t\t\t// the instance should have an .id property as well if the class does, so set that here\r\n\t\t\t\t\t\tstr.id = storeId;\r\n\t\t\t\t\t\t// if there is an id and there is a global state property for this store then merge\r\n\t\t\t\t\t\t// the properties from that global state into the default state of the store AND then\r\n\t\t\t\t\t\t// set the global state to that new state (since it may have previously been partial)\r\n\t\t\t\t\t\tif (storeId && Reflux.GlobalState[storeId]) {\r\n\t\t\t\t\t\t\tfor (var key in Reflux.GlobalState[storeId]) {\r\n\t\t\t\t\t\t\t\tstr.state[key] = Reflux.GlobalState[storeId][key];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tReflux.GlobalState[storeId] = str.state;\r\n\t\t\t\t\t\t// otherwise (if it has an id) set the global state to the default state of the store\r\n\t\t\t\t\t\t} else if (storeId) {\r\n\t\t\t\t\t\t\tReflux.GlobalState[storeId] = str.state;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if no id, then no messing with global state\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// listen/subscribe for the \".trigger()\" in the store, and track the unsubscribes so that we can unsubscribe on unmount\r\n\t\t\t\t\tif (!Reflux.serverMode) {\r\n\t\t\t\t\t\tthis.__storeunsubscribes__.push(str.listen(onStoreTrigger));\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// run set state so that it mixes in the props from the store with the component\r\n\t\t\t\t\tvar updateObj = filterByStoreKeys(this.storeKeys, str.state);\r\n\t\t\t\t\tif (updateObj) {\r\n\t\t\t\t\t\tthis.setState(updateObj);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// mapStoreToState needs to know if is ready to map or must wait\r\n\t\t\tthis.__readytomap__ = true;\r\n\t\t\t// if there are mappings that were delayed, do them now\r\n\t\t\tvar dmaps = this.__delayedmaps__;\r\n\t\t\tif (dmaps) {\r\n\t\t\t\tfor (var j=0,jj=dmaps.length; j<jj; j++) {\r\n\t\t\t\t\tdmaps[j].func( dmaps[j].state );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.__delayedmaps__ = null;\r\n\t\t};\r\n\t\t\r\n\t\t// on the unmount phase of the component unsubscribe that which we subscribed earlier to keep our garbage trail clean\r\n\t\tproto.componentWillUnmount = function () {\r\n\t\t\tif (this.__storeunsubscribes__) {\r\n\t\t\t\tfor (var i = 0, ii = this.__storeunsubscribes__.length; i < ii; i++) {\r\n\t\t\t\t\tthis.__storeunsubscribes__[i]();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.__readytomap__ = false;\r\n\t\t};\r\n\t\t\r\n\t\t/**\r\n\t\t * this.mapStoreToState\r\n\t\t * This function allow you to supply map the state of a store to the\r\n\t\t * state of this component manually via your own logic. This method\r\n\t\t * is completely separate from this.store/this.stores and/or this.storeKeys.\r\n\t\t * Call this function with an ES6 store (class or singleton instance) as the\r\n\t\t * first argument and your filter function as the second. Your filter function\r\n\t\t * will receive an object of the parts of the ES6 store being updated every\r\n\t\t * time its setState is called. Your filter function then returns an object\r\n\t\t * which will be merged with the component state (IF it has any properties at all,\r\n\t\t * should you return a blank object the component will not rerender).\r\n\t\t */\r\n\t\tproto.mapStoreToState = function(store, filterFunc)\r\n\t\t{\r\n\t\t\t// make sure we have a proper singleton instance to work with\r\n\t\t\tif (typeof store === 'function') {\r\n\t\t\t\tif (store.singleton) {\r\n\t\t\t\t\tstore = store.singleton;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstore = Reflux.initStore(store);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// we need a closure so that the called function can remember the proper filter function to use, so function gets defined here\r\n\t\t\tvar self = this;\r\n\t\t\tfunction onMapStoreTrigger(obj) {\r\n\t\t\t\t// get an object \r\n\t\t\t\tvar update = filterFunc.call(self, obj);\r\n\t\t\t\t// if no object returned from filter functions do nothing\r\n\t\t\t\tif (!update) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t// check if the update actually has any mapped props\r\n\t\t\t\t/*jshint unused: false */\r\n\t\t\t\tvar hasProps = false;\r\n\t\t\t\tfor (var check in update) {\r\n\t\t\t\t\thasProps = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t// if there were props mapped, then update via setState\r\n\t\t\t\tif (hasProps) {\r\n\t\t\t\t\tself.setState(update);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// add the listener to know when the store is triggered\r\n\t\t\tthis.__storeunsubscribes__ = this.__storeunsubscribes__ || [];\r\n\t\t\tthis.__storeunsubscribes__.push(store.listen(onMapStoreTrigger));\r\n\t\t\t\r\n\t\t\t// now actually run onMapStoreTrigger with the full store state so that we immediately have all store state mapped to component state\r\n\t\t\tif (this.__readytomap__) {\r\n\t\t\t\tonMapStoreTrigger(store.state);\r\n\t\t\t} else {\r\n\t\t\t\tthis.__delayedmaps__ = this.__delayedmaps__ || [];\r\n\t\t\t\tthis.__delayedmaps__.push({func:onMapStoreTrigger, state:store.state});\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\t/**\r\n\t\t * Reflux.Component.extend(OtherClass)\r\n\t\t * This allows you to get classes that extend off of another React.Component\r\n\t\t * inheriting class. For example if you're using a third party that uses\r\n\t\t * components that allow `class MyComponent extends LibComponent` (where LibComponent\r\n\t\t * itself extends React.Component) and you want to use that component with ES6 then\r\n\t\t * you can make a class `var MyDualComponent = Reflux.Component.extend(LibComponent);`\r\n\t\t * then you can use `class MyComponent extends MyDualComponent` to get the benefits\r\n\t\t * of both libraries.\r\n\t\t */\r\n\t\tRefluxComponent.extend = function(clss) {\r\n\t\t\treturn defineReact(null, null, clss);\r\n\t\t};\r\n\t\t\r\n\t\t// if is being manually called with an `extend` argument present then just return the created class\r\n\t\tif (extend) {\r\n\t\t\treturn RefluxComponent;\r\n\t\t}\r\n\t\t\r\n\t\t// otherwise set as Reflux.Component and continue with other normal definitions\r\n\t\tReflux.Component = RefluxComponent;\r\n\t\t\r\n\t\t// also set Reflux.PureComponent (if it exists) using the .extend feature\r\n\t\tif (_react.PureComponent) {\r\n\t\t\tReflux.PureComponent = RefluxComponent.extend(_react.PureComponent);\r\n\t\t}\r\n\t\t\r\n\t\t// ------------ END Reflux.Component ------------\r\n\t\t\r\n\t\t// --------- BEGIN Reflux.Store ------------\r\n\t\t/**\r\n\t\t * Reflux.Store:\r\n\t\t * Also implements optional Reflux.Store class that is idiomatic with\r\n\t\t * the React ES6 style. You extend Reflux.Store and then the rest works\r\n\t\t * the same as createStore, except the constructor instead of init, and\r\n\t\t * it holds state in a state property, and a .setState method is available\r\n\t\t * which automatically updates state and does a trigger. Then when using\r\n\t\t * with this.store or this.stores in an ES6 component just plass the class,\r\n\t\t * it will deal with a singleton instantiation of the class automatically.\r\n\t\t */\r\n\t\tvar RefluxStore = function() {\r\n\t\t\t// extending doesn't really work well here, so instead we create an internal instance\r\n\t\t\t// and just loop through its properties/methods and make a getter/setter for each\r\n\t\t\t// that will actually be getting and setting on that internal instance.\r\n\t\t\tthis.__store__ = Reflux.createStore();\r\n\t\t\tthis.state = {};\r\n\t\t\tvar self = this;\r\n\t\t\tfor (var key in this.__store__) {\r\n\t\t\t\t/*jshint loopfunc: true */\r\n\t\t\t\t(function (prop) {\r\n\t\t\t\t\tObject.defineProperty(self, prop, {\r\n\t\t\t\t\t\tget: function () { return self.__store__[prop]; },\r\n\t\t\t\t\t\tset: function (v) { self.__store__[prop] = v; }\r\n\t\t\t\t\t});\r\n\t\t\t\t})(key);\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tproto = RefluxStore.prototype;\r\n\t\t\r\n\t\t// this defines the listenables property, mostly intended to be set as `this.listenables` in the constructor of the store\r\n\t\t// it is essentially a shortcut to the `listenToMany` method\r\n\t\tObject.defineProperty(proto, \"listenables\", {\r\n\t\t\tget: function () {\r\n\t\t\t\treturn this.__listenables__;\r\n\t\t\t},\r\n\t\t\tset: function (v) {\r\n\t\t\t\tvar Combined = {};\r\n\t\t\t\tif (Array.isArray(v)){\r\n\t\t\t\t\tv.forEach(function(obj) {\r\n\t\t\t\t\t\tfor (var key in obj) {\r\n\t\t\t\t\t\t\tCombined[key] = obj[key];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tCombined = v;\r\n\t\t\t\t}\r\n\t\t\t\tthis.__listenables__ = Combined;\r\n\t\t\t\tthis.listenToMany(Combined);\r\n\t\t\t},\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: true\r\n\t\t});\r\n\t\t\r\n\t\t// allows simple usage of `this.setState(obj)` within the store to both update the state and trigger the store to update\r\n\t\t// components that it is attached to in a simple way that is idiomatic with React\r\n\t\tproto.setState = function (obj) {\r\n\t\t\t// Object.assign(this.state, obj); // later turn this to Object.assign and remove loop once support is good enough\r\n\t\t\tfor (var key in obj) {\r\n\t\t\t\tthis.state[key] = obj[key];\r\n\t\t\t}\r\n\t\t\t// if there's an id (i.e. it's being tracked by the global state) then make sure to update the global state\r\n\t\t\tif (this.id) {\r\n\t\t\t\tReflux.GlobalState[this.id] = this.state;\r\n\t\t\t}\r\n\t\t\t// trigger, because any component it's attached to is listening and will merge the store state into its own on a store trigger\r\n\t\t\tthis.trigger(obj);\r\n\t\t};\r\n\t\t\r\n\t\t// this is a static property so that other code can identify that this is a Reflux.Store class\r\n\t\t// has issues specifically when using babel to transpile your ES6 stores for IE10 and below, not documented and shouldn't use yet\r\n\t\tObject.defineProperty(RefluxStore, \"isES6Store\", {\r\n\t\t\tget: function () {\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: true\r\n\t\t});\r\n\t\t\r\n\t\t// allows a shortcut for accessing MyStore.singleton.state as MyStore.state (since common usage makes a singleton)\r\n\t\tObject.defineProperty(RefluxStore, \"state\", {\r\n\t\t\tget: function () {\r\n\t\t\t\tif (!this.singleton) {\r\n\t\t\t\t\tthrow new Error('Reflux.Store.state is inaccessible before the store has been initialized.');\r\n\t\t\t\t}\r\n\t\t\t\treturn this.singleton.state;\r\n\t\t\t},\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: true\r\n\t\t});\r\n\t\t\r\n\t\t/* NOTE:\r\n\t\tIf a Reflux.Store definition is given a static id property and used\r\n\t\tproperly within a Reflux.Component or with Reflux.initStore then\r\n\t\tit will be added to the Reflux.GlobalState object which automatically tracks the\r\n\t\tcurrent state of all such defined stores in the program. */\r\n\t\t\r\n\t\tReflux.Store = RefluxStore;\r\n\t\t// ----------- END Reflux.Store -------------\r\n\t\t\r\n\t\t// --------- BEGIN Reflux Static Props/Methods ------------\r\n\t\t/**\r\n\t\t * Reflux.GlobalState is where data is stored for any Reflux.Store that has a static id property. Each store's\r\n\t\t * state will be on the Reflux.GlobalState object with the id as the key. So a store with the id \"MyStore\" and\r\n\t\t * a state {\"color\":\"red\"} will end up with a Reflux.GlobalState of {\"MyStore\":{\"color\":\"red\"}}\r\n\t\t * Reflux.GlobalState is an accessible part of the API. However, keep in mind that non-primitive properties you\r\n\t\t * read off of it will continue to mutate and you can only manually mutate Reflux.GlobalState BEFORE any component\r\n\t\t * mounting of components with ES6 stores. For more functionality look to Reflux.setGlobalState to change the global\r\n\t\t * state at any point, and Reflux.getGlobalState to return a deep clone of the Reflux.GlobalState object which will\r\n\t\t * not continue to mutate as Reflux.GlobalState continues to mutate.\r\n\t\t */\r\n\t\tReflux.GlobalState = Reflux.GlobalState || {};\r\n\t\t\r\n\t\t/**\r\n\t\t * Reflux.stores\r\n\t\t * All initialized stores that have an id will have a reference to their singleton stored here with the key being the id.\r\n\t\t */\r\n\t\tReflux.stores = {};\r\n\t\t\r\n\t\t/**\r\n\t\t * Reflux.getGlobalState takes no arguments, and returns a deep clone of Reflux.GlobalState \r\n\t\t * which will not continue to mutate as Reflux.GlobalState does. It can essentially store\r\n\t\t * snapshots of the global state as the program goes for saving or for in-app time travel.\r\n\t\t */\r\n\t\tReflux.getGlobalState = function() {\r\n\t\t\treturn clone(Reflux.GlobalState);\r\n\t\t};\r\n\t\t\r\n\t\t/**\r\n\t\t * Reflux.setGlobalState takes one argument that is a representation of the a possible\r\n\t\t * global state. It updates all stores in the program to represent data in that given state.\r\n\t\t * This includes triggering those stores so that that state is represented in any Reflux.Component\r\n\t\t * instances they are attached to. Partial states may be given to it, and only the represented\r\n\t\t * stores/state values will be updated.\r\n\t\t */\r\n\t\tReflux.setGlobalState = function(obj) {\r\n\t\t\tfor (var storeID in obj) {\r\n\t\t\t\tif (Reflux.stores[storeID]) {\r\n\t\t\t\t\tReflux.stores[storeID].setState(obj[storeID]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tReflux.GlobalState[storeID] = obj[storeID];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\t/**\r\n\t\t * Reflux.initStore takes one argument (a class that extends Reflux.Store) and returns a singleton\r\n\t\t * intance of that class. Its main functionality is to be able to mimic what happens to stores attached to\r\n\t\t * this.store or this.stores during the mounting phase of a component without having to actually attach the\r\n\t\t * store to a component in order to work properly with the global state.\r\n\t\t */\r\n\t\t// Reflux.initializeGlobalStore is kept for backwards compatibility, but deprecated since the function is\r\n\t\t// now for more broad instantiation of globally stored AND non-globally stored classes\r\n\t\tReflux.initializeGlobalStore = Reflux.initStore = function(str) {\r\n\t\t\tvar storeId = str.id;\r\n\t\t\t// if they're initializing something twice then we're done already, return it\r\n\t\t\tif (str.singleton) {\r\n\t\t\t\treturn str.singleton;\r\n\t\t\t}\r\n\t\t\t// if no id then it's easy: just make new instance and set to singleton\r\n\t\t\tif (!storeId) {\r\n\t\t\t\tstr.singleton = new str();\r\n\t\t\t\treturn str.singleton;\r\n\t\t\t}\r\n\t\t\t// create the singleton and assign it to the class's singleton static property\r\n\t\t\tvar inst = str.singleton = new str();\r\n\t\t\t// store it on the Reflux.stores array to be accessible later\r\n\t\t\tReflux.stores[storeId] = inst;\r\n\t\t\t// the singleton instance itself should also have the id property of the class\r\n\t\t\tinst.id = storeId;\r\n\t\t\t// if the global state has something set for this id, copy it to the state and then\r\n\t\t\t// make sure to set the global state to the end result, since it may have only been partial\r\n\t\t\tif (Reflux.GlobalState[storeId]) {\r\n\t\t\t\tfor (var key in Reflux.GlobalState[storeId]) {\r\n\t\t\t\t\tinst.state[key] = Reflux.GlobalState[storeId][key];\r\n\t\t\t\t}\r\n\t\t\t\tReflux.GlobalState[storeId] = inst.state;\r\n\t\t\t// otherwise just set the global state to the default state of the class\r\n\t\t\t} else {\r\n\t\t\t\tReflux.GlobalState[storeId] = inst.state;\r\n\t\t\t}\r\n\t\t\t// returns the singleton itself, though it will also be accessible as as `MyClass.singleton`\r\n\t\t\treturn inst;\r\n\t\t};\r\n\t\t// --------- END Reflux Static Props/Methods ------------\r\n\t\t\r\n\t\t// so it knows not to redefine Reflux static stuff and stores if called again\r\n\t\t_defined = true;\r\n\t}\r\n\t\r\n\t// filters a state object by storeKeys array (if it exists)\r\n\t// if filtering and obj contains no properties to use, returns false to let the component know not to update\r\n\tfunction filterByStoreKeys(storeKeys, obj)\r\n\t{\r\n\t\t// if there are not storeKeys defined then simply return the whole original object\r\n\t\tif (!storeKeys) {\r\n\t\t\treturn obj;\r\n\t\t}\r\n\t\t// otherwise go through and only update properties that are in the storeKeys array, and return straight false if there are none\r\n\t\tvar doUpdate = false;\r\n\t\tvar updateObj = {};\r\n\t\tfor (var i = 0, ii = storeKeys.length; i < ii; i++) {\r\n\t\t\tvar prop = storeKeys[i];\r\n\t\t\tif (obj.hasOwnProperty(prop)) {\r\n\t\t\t\tdoUpdate = true;\r\n\t\t\t\tupdateObj[prop] = obj[prop];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn doUpdate ? updateObj : false;\r\n\t}\r\n\t\r\n\t// this is utilized by some of the global state functionality in order to get a clone that will\r\n\t// not continue to be modified as the GlobalState mutates\r\n\tfunction clone(frm, to) {\r\n\t\tif (frm === null || typeof frm !== \"object\") {\r\n\t\t\treturn frm;\r\n\t\t}\r\n\t\tif (frm.constructor !== Object && frm.constructor !== Array) {\r\n\t\t\treturn frm;\r\n\t\t}\r\n\t\tif (frm.constructor === Date || frm.constructor === RegExp || frm.constructor === Function ||\r\n\t\t\tfrm.constructor === String || frm.constructor === Number || frm.constructor === Boolean) {\r\n\t\t\treturn new frm.constructor(frm);\r\n\t\t}\r\n\t\tto = to || new frm.constructor();\r\n\t\tfor (var name in frm) {\r\n\t\t\tto[name] = typeof to[name] === \"undefined\" ? clone(frm[name], null) : to[name];\r\n\t\t}\r\n\t\treturn to;\r\n\t}\r\n\t\r\n\tmodule.exports = defineReact;\r\n\t\r\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\n\tif(typeof __WEBPACK_EXTERNAL_MODULE_22__ === 'undefined') {var e = new Error(\"Cannot find module \\\"undefined\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e;}\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_22__;\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// ./dist/reflux-rehydrate.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 85ad1bdbe43049037386","import Reflux from 'reflux';\n\nReflux.rehydrate = (str, data) => {\n    return Reflux.initStore(str).setState(data);\n};\n\nexport default Reflux;\n\nexport function initStore(str) {\n  str.prototype.rehydrate = function(state){\n    this.setState(state);\n  };\n  return Reflux.initStore(str);\n}\n\n export function createActions(actions){\n  let rehydrateActions = ['rehydrate'];\n  actions = rehydrateActions.concat(actions);\n  return Reflux.createActions(actions);\n} \n\n\n\n// WEBPACK FOOTER //\n// ./lib/index.js","var Reflux = require('reflux-core');\r\n\r\nReflux.serverMode = typeof window !== 'object';\r\n\r\nReflux.connect = require('./connect');\r\n\r\nReflux.connectFilter = require('./connectFilter');\r\n\r\nReflux.ListenerMixin = require('./ListenerMixin');\r\n\r\nReflux.listenTo = require('./listenTo');\r\n\r\nReflux.listenToMany = require('./listenToMany');\r\n\r\nrequire('./addES6');\r\n\r\nmodule.exports = Reflux;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux/src/index.js\n// module id = 1\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.__keep = exports.joinConcat = exports.joinStrict = exports.joinLeading = exports.all = exports.joinTrailing = exports.use = exports.nextTick = exports.setEventEmitter = exports.createActions = exports.createStore = exports.createAction = exports.utils = exports.StoreMethods = exports.PublisherMethods = exports.ListenerMethods = exports.ActionMethods = exports.version = undefined;\n\nvar _ActionMethods = require(\"./ActionMethods\");\n\nvar ActionMethods = _interopRequireWildcard(_ActionMethods);\n\nvar _ListenerMethods = require(\"./ListenerMethods\");\n\nvar ListenerMethods = _interopRequireWildcard(_ListenerMethods);\n\nvar _PublisherMethods = require(\"./PublisherMethods\");\n\nvar PublisherMethods = _interopRequireWildcard(_PublisherMethods);\n\nvar _StoreMethods = require(\"./StoreMethods\");\n\nvar StoreMethods = _interopRequireWildcard(_StoreMethods);\n\nvar _joins = require(\"./joins\");\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nvar _createAction = require(\"./createAction\");\n\nvar _createStore = require(\"./createStore\");\n\nvar _Keep = require(\"./Keep\");\n\nvar __keep = _interopRequireWildcard(_Keep);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar version = {\n    \"reflux-core\": \"1.0.0\"\n};\n\nvar joinTrailing = (0, _joins.staticJoinCreator)(\"last\");\nvar all = joinTrailing; // Reflux.all alias for backward compatibility\nvar joinLeading = (0, _joins.staticJoinCreator)(\"first\");\nvar joinStrict = (0, _joins.staticJoinCreator)(\"strict\");\nvar joinConcat = (0, _joins.staticJoinCreator)(\"all\");\n\nvar utils = _;\n\n\n/**\r\n * Convenience function for creating a set of actions\r\n *\r\n * @param definitions the definitions for the actions to be created\r\n * @returns an object with actions of corresponding action names\r\n */\nvar createActions = function () {\n    var reducer = function reducer(definitions, actions) {\n        Object.keys(definitions).forEach(function (actionName) {\n            var val = definitions[actionName];\n            actions[actionName] = (0, _createAction.createAction)(val);\n        });\n    };\n\n    return function (definitions) {\n        var actions = {};\n        if (definitions instanceof Array) {\n            definitions.forEach(function (val) {\n                if (_.isObject(val)) {\n                    reducer(val, actions);\n                } else {\n                    actions[val] = (0, _createAction.createAction)(val);\n                }\n            });\n        } else {\n            reducer(definitions, actions);\n        }\n        return actions;\n    };\n}();\n\n/**\r\n * Sets the eventmitter that Reflux uses\r\n */\nfunction setEventEmitter(ctx) {\n    _.EventEmitter = ctx;\n}\n\n/**\r\n * Sets the method used for deferring actions and stores\r\n */\nfunction nextTick(nextTick) {\n    _.nextTick = nextTick;\n}\n\nfunction use(pluginCb) {\n    pluginCb(this);\n}\n\n/**\r\n * Provides the set of created actions and stores for introspection\r\n */\n/*eslint-disable no-underscore-dangle*/\n\n\n// export in format that supports syntax: var Reflux = require('reflux-core');\nexports.version = version;\nexports.ActionMethods = ActionMethods;\nexports.ListenerMethods = ListenerMethods;\nexports.PublisherMethods = PublisherMethods;\nexports.StoreMethods = StoreMethods;\nexports.utils = utils;\nexports.createAction = _createAction.createAction;\nexports.createStore = _createStore.createStore;\nexports.createActions = createActions;\nexports.setEventEmitter = setEventEmitter;\nexports.nextTick = nextTick;\nexports.use = use;\nexports.joinTrailing = joinTrailing;\nexports.all = all;\nexports.joinLeading = joinLeading;\nexports.joinStrict = joinStrict;\nexports.joinConcat = joinConcat;\nexports.__keep = __keep;\n/*eslint-enable no-underscore-dangle*/\n\n// export in format that supports syntax: import Reflux from 'reflux-core';\n\nObject.defineProperty(exports, \"default\", {\n    get: function get() {\n        return exports;\n    }\n});\n\n/**\r\n * Warn if Function.prototype.bind not available\r\n */\nif (!Function.prototype.bind) {\n    console.error(\"Function.prototype.bind not available. \" + \"ES5 shim required. \" + \"https://github.com/spoike/refluxjs#es5\");\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux-core/lib/index.js\n// module id = 2\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux-core/lib/ActionMethods.js\n// module id = 3\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.joinStrict = exports.joinConcat = exports.joinLeading = exports.joinTrailing = exports.fetchInitialState = exports.stopListeningToAll = exports.stopListeningTo = exports.listenTo = exports.validateListening = exports.listenToMany = exports.hasListener = undefined;\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nvar _joins = require(\"./joins\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\r\n * Extract child listenables from a parent from their\r\n * children property and return them in a keyed Object\r\n *\r\n * @param {Object} listenable The parent listenable\r\n */\nvar mapChildListenables = function mapChildListenables(listenable) {\n    var i = 0,\n        children = {},\n        childName;\n    for (; i < (listenable.children || []).length; ++i) {\n        childName = listenable.children[i];\n        if (listenable[childName]) {\n            children[childName] = listenable[childName];\n        }\n    }\n    return children;\n};\n\n/**\r\n * Make a flat dictionary of all listenables including their\r\n * possible children (recursively), concatenating names in camelCase.\r\n *\r\n * @param {Object} listenables The top-level listenables\r\n */\nvar flattenListenables = function flattenListenables(listenables) {\n    var flattened = {};\n    for (var key in listenables) {\n        var listenable = listenables[key];\n        var childMap = mapChildListenables(listenable);\n\n        // recursively flatten children\n        var children = flattenListenables(childMap);\n\n        // add the primary listenable and chilren\n        flattened[key] = listenable;\n        for (var childKey in children) {\n            var childListenable = children[childKey];\n            flattened[key + _.capitalize(childKey)] = childListenable;\n        }\n    }\n\n    return flattened;\n};\n\n/**\r\n * An internal utility function used by `validateListening`\r\n *\r\n * @param {Action|Store} listenable The listenable we want to search for\r\n * @returns {Boolean} The result of a recursive search among `this.subscriptions`\r\n */\nvar hasListener = exports.hasListener = function hasListener(listenable) {\n    var i = 0,\n        j,\n        listener,\n        listenables;\n    for (; i < (this.subscriptions || []).length; ++i) {\n        listenables = [].concat(this.subscriptions[i].listenable);\n        for (j = 0; j < listenables.length; j++) {\n            listener = listenables[j];\n            if (listener === listenable || listener.hasListener && listener.hasListener(listenable)) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\n/**\r\n * A convenience method that listens to all listenables in the given object.\r\n *\r\n * @param {Object} listenables An object of listenables. Keys will be used as callback method names.\r\n */\nvar listenToMany = exports.listenToMany = function listenToMany(listenables) {\n    var allListenables = flattenListenables(listenables);\n    for (var key in allListenables) {\n        var cbname = _.callbackName(key),\n            localname = this[cbname] ? cbname : this[key] ? key : undefined;\n        if (localname) {\n            this.listenTo(allListenables[key], localname, this[cbname + \"Default\"] || this[localname + \"Default\"] || localname);\n        }\n    }\n};\n\n/**\r\n * Checks if the current context can listen to the supplied listenable\r\n *\r\n * @param {Action|Store} listenable An Action or Store that should be\r\n *  listened to.\r\n * @returns {String|Undefined} An error message, or undefined if there was no problem.\r\n */\nvar validateListening = exports.validateListening = function validateListening(listenable) {\n    if (listenable === this) {\n        return \"Listener is not able to listen to itself\";\n    }\n    if (!_.isFunction(listenable.listen)) {\n        return listenable + \" is missing a listen method\";\n    }\n    if (listenable.hasListener && listenable.hasListener(this)) {\n        return \"Listener cannot listen to this listenable because of circular loop\";\n    }\n};\n\n/**\r\n * Sets up a subscription to the given listenable for the context object\r\n *\r\n * @param {Action|Store} listenable An Action or Store that should be\r\n *  listened to.\r\n * @param {Function|String} callback The callback to register as event handler\r\n * @param {Function|String} defaultCallback The callback to register as default handler\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to\r\n */\nvar listenTo = exports.listenTo = function listenTo(listenable, callback, defaultCallback) {\n    var desub,\n        unsubscriber,\n        subscriptionobj,\n        subs = this.subscriptions = this.subscriptions || [];\n    _.throwIf(this.validateListening(listenable));\n    this.fetchInitialState(listenable, defaultCallback);\n    desub = listenable.listen(this[callback] || callback, this);\n    unsubscriber = function unsubscriber() {\n        var index = subs.indexOf(subscriptionobj);\n        _.throwIf(index === -1, \"Tried to remove listen already gone from subscriptions list!\");\n        subs.splice(index, 1);\n        desub();\n    };\n    subscriptionobj = {\n        stop: unsubscriber,\n        listenable: listenable\n    };\n    subs.push(subscriptionobj);\n    return subscriptionobj;\n};\n\n/**\r\n * Stops listening to a single listenable\r\n *\r\n * @param {Action|Store} listenable The action or store we no longer want to listen to\r\n * @returns {Boolean} True if a subscription was found and removed, otherwise false.\r\n */\nvar stopListeningTo = exports.stopListeningTo = function stopListeningTo(listenable) {\n    var sub,\n        i = 0,\n        subs = this.subscriptions || [];\n    for (; i < subs.length; i++) {\n        sub = subs[i];\n        if (sub.listenable === listenable) {\n            sub.stop();\n            _.throwIf(subs.indexOf(sub) !== -1, \"Failed to remove listen from subscriptions list!\");\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\r\n * Stops all subscriptions and empties subscriptions array\r\n */\nvar stopListeningToAll = exports.stopListeningToAll = function stopListeningToAll() {\n    var remaining,\n        subs = this.subscriptions || [];\n    while (remaining = subs.length) {\n        subs[0].stop();\n        _.throwIf(subs.length !== remaining - 1, \"Failed to remove listen from subscriptions list!\");\n    }\n};\n\n/**\r\n * Used in `listenTo`. Fetches initial data from a publisher if it has a `getInitialState` method.\r\n * @param {Action|Store} listenable The publisher we want to get initial state from\r\n * @param {Function|String} defaultCallback The method to receive the data\r\n */\nvar fetchInitialState = exports.fetchInitialState = function fetchInitialState(listenable, defaultCallback) {\n    defaultCallback = defaultCallback && this[defaultCallback] || defaultCallback;\n    var me = this;\n    if (_.isFunction(defaultCallback) && _.isFunction(listenable.getInitialState)) {\n        var data = listenable.getInitialState();\n        if (data && _.isFunction(data.then)) {\n            data.then(function () {\n                defaultCallback.apply(me, arguments);\n            });\n        } else {\n            defaultCallback.call(this, data);\n        }\n    }\n};\n\n/**\r\n * The callback will be called once all listenables have triggered at least once.\r\n * It will be invoked with the last emission from each listenable.\r\n * @param {...Publishers} publishers Publishers that should be tracked.\r\n * @param {Function|String} callback The method to call when all publishers have emitted\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n */\nvar joinTrailing = exports.joinTrailing = (0, _joins.instanceJoinCreator)(\"last\");\n\n/**\r\n * The callback will be called once all listenables have triggered at least once.\r\n * It will be invoked with the first emission from each listenable.\r\n * @param {...Publishers} publishers Publishers that should be tracked.\r\n * @param {Function|String} callback The method to call when all publishers have emitted\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n */\nvar joinLeading = exports.joinLeading = (0, _joins.instanceJoinCreator)(\"first\");\n\n/**\r\n * The callback will be called once all listenables have triggered at least once.\r\n * It will be invoked with all emission from each listenable.\r\n * @param {...Publishers} publishers Publishers that should be tracked.\r\n * @param {Function|String} callback The method to call when all publishers have emitted\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n */\nvar joinConcat = exports.joinConcat = (0, _joins.instanceJoinCreator)(\"all\");\n\n/**\r\n * The callback will be called once all listenables have triggered.\r\n * If a callback triggers twice before that happens, an error is thrown.\r\n * @param {...Publishers} publishers Publishers that should be tracked.\r\n * @param {Function|String} callback The method to call when all publishers have emitted\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n */\nvar joinStrict = exports.joinStrict = (0, _joins.instanceJoinCreator)(\"strict\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux-core/lib/ListenerMethods.js\n// module id = 4\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.capitalize = capitalize;\nexports.callbackName = callbackName;\nexports.isObject = isObject;\nexports.extend = extend;\nexports.isFunction = isFunction;\nexports.nextTick = nextTick;\nexports.object = object;\nexports.isArguments = isArguments;\nexports.throwIf = throwIf;\nfunction capitalize(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nfunction callbackName(string, prefix) {\n    prefix = prefix || \"on\";\n    return prefix + exports.capitalize(string);\n}\n\n/*\r\n * isObject, extend, isFunction, isArguments are taken from underscore/lodash in\r\n * order to remove the dependency\r\n */\nfunction isObject(obj) {\n    var type = typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n    return type === \"function\" || type === \"object\" && !!obj;\n}\n\nfunction extend(obj) {\n    if (!isObject(obj)) {\n        return obj;\n    }\n    var source, keys, prop;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n        source = arguments[i];\n        keys = Object.keys(source);\n        for (var j = 0; j < keys.length; j++) {\n            prop = keys[j];\n            if (Object.getOwnPropertyDescriptor && Object.defineProperty) {\n                var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\n                Object.defineProperty(obj, prop, propertyDescriptor);\n            } else {\n                obj[prop] = source[prop];\n            }\n        }\n    }\n    return obj;\n}\n\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\n\nexports.EventEmitter = require(\"eventemitter3\");\n\nfunction nextTick(callback) {\n    setTimeout(callback, 0);\n}\n\nfunction object(keys, vals) {\n    var o = {},\n        i = 0;\n    for (; i < keys.length; i++) {\n        o[keys[i]] = vals[i];\n    }\n    return o;\n}\n\nfunction isArguments(value) {\n    return (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" && \"callee\" in value && typeof value.length === \"number\";\n}\n\nfunction throwIf(val, msg) {\n    if (val) {\n        throw Error(msg || val);\n    }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux-core/lib/utils.js\n// module id = 5\n// module chunks = 0","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} [once=false] Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Hold the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var events = this._events\n    , names = []\n    , name;\n\n  if (!events) return names;\n\n  for (name in events) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/eventemitter3/index.js\n// module id = 6\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.staticJoinCreator = staticJoinCreator;\nexports.instanceJoinCreator = instanceJoinCreator;\n\nvar _createStore = require(\"./createStore\");\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\r\n * Internal module used to create static and instance join methods\r\n */\n\nvar slice = Array.prototype.slice,\n    strategyMethodNames = {\n    strict: \"joinStrict\",\n    first: \"joinLeading\",\n    last: \"joinTrailing\",\n    all: \"joinConcat\"\n};\n\n/**\r\n * Used in `index.js` to create the static join methods\r\n * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\r\n * @returns {Function} A static function which returns a store with a join listen on the given listenables using the given strategy\r\n */\nfunction staticJoinCreator(strategy) {\n    return function () /* listenables... */{\n        var listenables = slice.call(arguments);\n        return (0, _createStore.createStore)({\n            init: function init() {\n                this[strategyMethodNames[strategy]].apply(this, listenables.concat(\"triggerAsync\"));\n            }\n        });\n    };\n}\n\n/**\r\n * Used in `ListenerMethods.js` to create the instance join methods\r\n * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\r\n * @returns {Function} An instance method which sets up a join listen on the given listenables using the given strategy\r\n */\nfunction instanceJoinCreator(strategy) {\n    return function () /* listenables..., callback*/{\n        _.throwIf(arguments.length < 2, \"Cannot create a join with less than 2 listenables!\");\n        var listenables = slice.call(arguments),\n            callback = listenables.pop(),\n            numberOfListenables = listenables.length,\n            join = {\n            numberOfListenables: numberOfListenables,\n            callback: this[callback] || callback,\n            listener: this,\n            strategy: strategy\n        },\n            i,\n            cancels = [],\n            subobj;\n        for (i = 0; i < numberOfListenables; i++) {\n            _.throwIf(this.validateListening(listenables[i]));\n        }\n        for (i = 0; i < numberOfListenables; i++) {\n            cancels.push(listenables[i].listen(newListener(i, join), this));\n        }\n        reset(join);\n        subobj = { listenable: listenables };\n        subobj.stop = makeStopper(subobj, cancels, this);\n        this.subscriptions = (this.subscriptions || []).concat(subobj);\n        return subobj;\n    };\n}\n\n// ---- internal join functions ----\n\nfunction makeStopper(subobj, cancels, context) {\n    return function () {\n        var i,\n            subs = context.subscriptions,\n            index = subs ? subs.indexOf(subobj) : -1;\n        _.throwIf(index === -1, \"Tried to remove join already gone from subscriptions list!\");\n        for (i = 0; i < cancels.length; i++) {\n            cancels[i]();\n        }\n        subs.splice(index, 1);\n    };\n}\n\nfunction reset(join) {\n    join.listenablesEmitted = new Array(join.numberOfListenables);\n    join.args = new Array(join.numberOfListenables);\n}\n\nfunction newListener(i, join) {\n    return function () {\n        var callargs = slice.call(arguments);\n        if (join.listenablesEmitted[i]) {\n            switch (join.strategy) {\n                case \"strict\":\n                    throw new Error(\"Strict join failed because listener triggered twice.\");\n                case \"last\":\n                    join.args[i] = callargs;break;\n                case \"all\":\n                    join.args[i].push(callargs);\n            }\n        } else {\n            join.listenablesEmitted[i] = true;\n            join.args[i] = join.strategy === \"all\" ? [callargs] : callargs;\n        }\n        emitIfAllListenablesEmitted(join);\n    };\n}\n\nfunction emitIfAllListenablesEmitted(join) {\n    for (var i = 0; i < join.numberOfListenables; i++) {\n        if (!join.listenablesEmitted[i]) {\n            return;\n        }\n    }\n    join.callback.apply(join.listener, join.args);\n    reset(join);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux-core/lib/joins.js\n// module id = 7\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.createStore = createStore;\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nvar _Keep = require(\"./Keep\");\n\nvar Keep = _interopRequireWildcard(_Keep);\n\nvar _mixer = require(\"./mixer\");\n\nvar _bindMethods = require(\"./bindMethods\");\n\nvar _StoreMethods = require(\"./StoreMethods\");\n\nvar StoreMethods = _interopRequireWildcard(_StoreMethods);\n\nvar _PublisherMethods = require(\"./PublisherMethods\");\n\nvar PublisherMethods = _interopRequireWildcard(_PublisherMethods);\n\nvar _ListenerMethods = require(\"./ListenerMethods\");\n\nvar ListenerMethods = _interopRequireWildcard(_ListenerMethods);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar allowed = { preEmit: 1, shouldEmit: 1 };\n\n/**\r\n * Creates an event emitting Data Store. It is mixed in with functions\r\n * from the `ListenerMethods` and `PublisherMethods` mixins. `preEmit`\r\n * and `shouldEmit` may be overridden in the definition object.\r\n *\r\n * @param {Object} definition The data store object definition\r\n * @returns {Store} A data store instance\r\n */\nfunction createStore(definition) {\n\n    definition = definition || {};\n\n    for (var a in StoreMethods) {\n        if (!allowed[a] && (PublisherMethods[a] || ListenerMethods[a])) {\n            throw new Error(\"Cannot override API method \" + a + \" in Reflux.StoreMethods. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.\");\n        }\n    }\n\n    for (var d in definition) {\n        if (!allowed[d] && (PublisherMethods[d] || ListenerMethods[d])) {\n            throw new Error(\"Cannot override API method \" + d + \" in store creation. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.\");\n        }\n    }\n\n    definition = (0, _mixer.mix)(definition);\n\n    function Store() {\n        var i = 0,\n            arr;\n        this.subscriptions = [];\n        this.emitter = new _.EventEmitter();\n        this.eventLabel = \"change\";\n        (0, _bindMethods.bindMethods)(this, definition);\n        if (this.init && _.isFunction(this.init)) {\n            this.init();\n        }\n        if (this.listenables) {\n            arr = [].concat(this.listenables);\n            for (; i < arr.length; i++) {\n                this.listenToMany(arr[i]);\n            }\n        }\n    }\n\n    _.extend(Store.prototype, ListenerMethods, PublisherMethods, StoreMethods, definition);\n\n    var store = new Store();\n    Keep.addStore(store);\n\n    return store;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux-core/lib/createStore.js\n// module id = 8\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\n// this needs to be set to true before Keep.js starts storing, done via useKeep\nvar use = false;\n\nvar createdStores = [];\n\nvar createdActions = [];\n\nfunction useKeep() {\n\tvar bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n\tuse = bool;\n}\n\nfunction addStore(str) {\n\tif (use) {\n\t\tcreatedStores.push(str);\n\t}\n}\n\nfunction addAction(act) {\n\tif (use) {\n\t\tcreatedActions.push(act);\n\t}\n}\n\nfunction reset() {\n\twhile (createdStores.length) {\n\t\tcreatedStores.pop();\n\t}\n\twhile (createdActions.length) {\n\t\tcreatedActions.pop();\n\t}\n}\n\nexports.useKeep = useKeep;\nexports.addStore = addStore;\nexports.addAction = addAction;\nexports.createdStores = createdStores;\nexports.createdActions = createdActions;\nexports.reset = reset;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux-core/lib/Keep.js\n// module id = 9\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.mix = mix;\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction mix(def) {\n    var composed = {\n        init: [],\n        preEmit: [],\n        shouldEmit: []\n    };\n\n    var updated = function mixDef(mixin) {\n        var mixed = {};\n        if (mixin.mixins) {\n            mixin.mixins.forEach(function (subMixin) {\n                _.extend(mixed, mixDef(subMixin));\n            });\n        }\n        _.extend(mixed, mixin);\n        Object.keys(composed).forEach(function (composable) {\n            if (mixin.hasOwnProperty(composable)) {\n                composed[composable].push(mixin[composable]);\n            }\n        });\n        return mixed;\n    }(def);\n\n    if (composed.init.length > 1) {\n        updated.init = function () {\n            var args = arguments;\n            composed.init.forEach(function (init) {\n                init.apply(this, args);\n            }, this);\n        };\n    }\n    if (composed.preEmit.length > 1) {\n        updated.preEmit = function () {\n            return composed.preEmit.reduce(function (args, preEmit) {\n                var newValue = preEmit.apply(this, args);\n                return newValue === undefined ? args : [newValue];\n            }.bind(this), arguments);\n        };\n    }\n    if (composed.shouldEmit.length > 1) {\n        updated.shouldEmit = function () {\n            var args = arguments;\n            return !composed.shouldEmit.some(function (shouldEmit) {\n                return !shouldEmit.apply(this, args);\n            }, this);\n        };\n    }\n    Object.keys(composed).forEach(function (composable) {\n        if (composed[composable].length === 1) {\n            updated[composable] = composed[composable][0];\n        }\n    });\n\n    return updated;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux-core/lib/mixer.js\n// module id = 10\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.bindMethods = bindMethods;\nfunction bindMethods(store, definition) {\n    for (var name in definition) {\n        if (Object.getOwnPropertyDescriptor && Object.defineProperty) {\n            var propertyDescriptor = Object.getOwnPropertyDescriptor(definition, name);\n\n            if (!propertyDescriptor.value || typeof propertyDescriptor.value !== \"function\" || !definition.hasOwnProperty(name)) {\n                continue;\n            }\n\n            store[name] = definition[name].bind(store);\n        } else {\n            var property = definition[name];\n\n            if (typeof property !== \"function\" || !definition.hasOwnProperty(name)) {\n                continue;\n            }\n\n            store[name] = property.bind(store);\n        }\n    }\n\n    return store;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux-core/lib/bindMethods.js\n// module id = 11\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux-core/lib/StoreMethods.js\n// module id = 12\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.deferWith = exports.triggerAsync = exports.trigger = exports.listen = exports.shouldEmit = exports.preEmit = undefined;\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\r\n * A module of methods for object that you want to be able to listen to.\r\n * This module is consumed by `createStore` and `createAction`\r\n */\n\n/**\r\n * Hook used by the publisher that is invoked before emitting\r\n * and before `shouldEmit`. The arguments are the ones that the action\r\n * is invoked with. If this function returns something other than\r\n * undefined, that will be passed on as arguments for shouldEmit and\r\n * emission.\r\n */\nvar preEmit = exports.preEmit = function preEmit() {};\n\n/**\r\n * Hook used by the publisher after `preEmit` to determine if the\r\n * event should be emitted with given arguments. This may be overridden\r\n * in your application, default implementation always returns true.\r\n *\r\n * @returns {Boolean} true if event should be emitted\r\n */\nvar shouldEmit = exports.shouldEmit = function shouldEmit() {\n    return true;\n};\n\n/**\r\n * Subscribes the given callback for action triggered\r\n *\r\n * @param {Function} callback The callback to register as event handler\r\n * @param {Mixed} [optional] bindContext The context to bind the callback with\r\n * @returns {Function} Callback that unsubscribes the registered event handler\r\n */\nvar listen = exports.listen = function listen(callback, bindContext) {\n    bindContext = bindContext || this;\n    var eventHandler = function eventHandler(args) {\n        if (aborted) {\n            return;\n        }\n        callback.apply(bindContext, args);\n    },\n        me = this,\n        aborted = false;\n    this.emitter.addListener(this.eventLabel, eventHandler);\n    return function () {\n        aborted = true;\n        me.emitter.removeListener(me.eventLabel, eventHandler);\n    };\n};\n\n/**\r\n * Publishes an event using `this.emitter` (if `shouldEmit` agrees)\r\n */\nvar trigger = exports.trigger = function trigger() {\n    var args = arguments,\n        pre = this.preEmit.apply(this, args);\n    args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);\n    if (this.shouldEmit.apply(this, args)) {\n        this.emitter.emit(this.eventLabel, args);\n    }\n};\n\n/**\r\n * Tries to publish the event on the next tick\r\n */\nvar triggerAsync = exports.triggerAsync = function triggerAsync() {\n    var args = arguments,\n        me = this;\n    _.nextTick(function () {\n        me.trigger.apply(me, args);\n    });\n};\n\n/**\r\n * Wraps the trigger mechanism with a deferral function.\r\n *\r\n * @param {Function} callback the deferral function,\r\n *        first argument is the resolving function and the\r\n *        rest are the arguments provided from the previous\r\n *        trigger invocation\r\n */\nvar deferWith = exports.deferWith = function deferWith(callback) {\n    var oldTrigger = this.trigger,\n        ctx = this,\n        resolver = function resolver() {\n        oldTrigger.apply(ctx, arguments);\n    };\n    this.trigger = function () {\n        callback.apply(ctx, [resolver].concat([].splice.call(arguments, 0)));\n    };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux-core/lib/PublisherMethods.js\n// module id = 13\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.createAction = createAction;\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nvar _ActionMethods = require(\"./ActionMethods\");\n\nvar ActionMethods = _interopRequireWildcard(_ActionMethods);\n\nvar _PublisherMethods = require(\"./PublisherMethods\");\n\nvar PublisherMethods = _interopRequireWildcard(_PublisherMethods);\n\nvar _Keep = require(\"./Keep\");\n\nvar Keep = _interopRequireWildcard(_Keep);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar allowed = { preEmit: 1, shouldEmit: 1 };\n\n/**\r\n * Creates an action functor object. It is mixed in with functions\r\n * from the `PublisherMethods` mixin. `preEmit` and `shouldEmit` may\r\n * be overridden in the definition object.\r\n *\r\n * @param {Object} definition The action object definition\r\n */\nfunction createAction(definition) {\n\n    definition = definition || {};\n    if (!_.isObject(definition)) {\n        definition = { actionName: definition };\n    }\n\n    for (var a in ActionMethods) {\n        if (!allowed[a] && PublisherMethods[a]) {\n            throw new Error(\"Cannot override API method \" + a + \" in Reflux.ActionMethods. Use another method name or override it on Reflux.PublisherMethods instead.\");\n        }\n    }\n\n    for (var d in definition) {\n        if (!allowed[d] && PublisherMethods[d]) {\n            throw new Error(\"Cannot override API method \" + d + \" in action creation. Use another method name or override it on Reflux.PublisherMethods instead.\");\n        }\n    }\n\n    definition.children = definition.children || [];\n    if (definition.asyncResult) {\n        definition.children = definition.children.concat([\"completed\", \"failed\"]);\n    }\n\n    var i = 0,\n        childActions = {};\n    for (; i < definition.children.length; i++) {\n        var chDef = definition.children[i];\n        var chName = typeof chDef === \"string\" ? chDef : chDef.actionName;\n        childActions[chName] = createAction(chDef);\n    }\n\n    var context = _.extend({\n        eventLabel: \"action\",\n        emitter: new _.EventEmitter(),\n        _isAction: true\n    }, PublisherMethods, ActionMethods, definition);\n\n    var functor = function functor() {\n        var hasChildActions = false;\n        /* eslint no-unused-vars:0 */\n        for (var ignore in functor.childActions) {\n            hasChildActions = true;break;\n        }\n        var async = !functor.sync && typeof functor.sync !== \"undefined\" || hasChildActions;\n        var triggerType = async ? \"triggerAsync\" : \"trigger\";\n        return functor[triggerType].apply(functor, arguments);\n    };\n\n    _.extend(functor, childActions, context);\n\n    Keep.addAction(functor);\n\n    return functor;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux-core/lib/createAction.js\n// module id = 14\n// module chunks = 0","var ListenerMethods = require('reflux-core/lib/ListenerMethods'),\r\n    ListenerMixin = require('./ListenerMixin'),\r\n    _ = require('reflux-core/lib/utils');\r\n\r\nmodule.exports = function(listenable, key) {\r\n\r\n    _.throwIf(typeof(key) === 'undefined', 'Reflux.connect() requires a key.');\r\n\r\n    return {\r\n        getInitialState: function() {\r\n            if (!_.isFunction(listenable.getInitialState)) {\r\n                return {};\r\n            }\r\n\r\n            return _.object([key],[listenable.getInitialState()]);\r\n        },\r\n        componentDidMount: function() {\r\n            var me = this;\r\n\r\n            _.extend(me, ListenerMethods);\r\n\r\n            this.listenTo(listenable, function(v) {\r\n                me.setState(_.object([key],[v]));\r\n            });\r\n        },\r\n        componentWillUnmount: ListenerMixin.componentWillUnmount\r\n    };\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux/src/connect.js\n// module id = 15\n// module chunks = 0","var _ = require('reflux-core/lib/utils'),\r\n    ListenerMethods = require('reflux-core/lib/ListenerMethods');\r\n\r\n/**\r\n * A module meant to be consumed as a mixin by a React component. Supplies the methods from\r\n * `ListenerMethods` mixin and takes care of teardown of subscriptions.\r\n * Note that if you're using the `connect` mixin you don't need this mixin, as connect will\r\n * import everything this mixin contains!\r\n */\r\nmodule.exports = _.extend({\r\n\r\n    /**\r\n     * Cleans up all listener previously registered.\r\n     */\r\n    componentWillUnmount: ListenerMethods.stopListeningToAll\r\n\r\n}, ListenerMethods);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux/src/ListenerMixin.js\n// module id = 16\n// module chunks = 0","var ListenerMethods = require('reflux-core/lib/ListenerMethods'),\r\n    ListenerMixin = require('./ListenerMixin'),\r\n    _ = require('reflux-core/lib/utils');\r\n\r\nmodule.exports = function(listenable, key, filterFunc) {\r\n\r\n    _.throwIf(_.isFunction(key), 'Reflux.connectFilter() requires a key.');\r\n\r\n    return {\r\n        getInitialState: function() {\r\n            if (!_.isFunction(listenable.getInitialState)) {\r\n                return {};\r\n            }\r\n\r\n            // Filter initial payload from store.\r\n            var result = filterFunc.call(this, listenable.getInitialState());\r\n            if (typeof(result) !== 'undefined') {\r\n                return _.object([key], [result]);\r\n            } else {\r\n                return {};\r\n            }\r\n        },\r\n        componentDidMount: function() {\r\n            var me = this;\r\n\r\n            _.extend(this, ListenerMethods);\r\n\r\n            this.listenTo(listenable, function(value) {\r\n                var result = filterFunc.call(me, value);\r\n                me.setState(_.object([key], [result]));\r\n            });\r\n        },\r\n        componentWillUnmount: ListenerMixin.componentWillUnmount\r\n    };\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux/src/connectFilter.js\n// module id = 17\n// module chunks = 0","var ListenerMethods = require('reflux-core/lib/ListenerMethods');\r\n\r\n/**\r\n * A mixin factory for a React component. Meant as a more convenient way of using the `ListenerMixin`,\r\n * without having to manually set listeners in the `componentDidMount` method.\r\n *\r\n * @param {Action|Store} listenable An Action or Store that should be\r\n *  listened to.\r\n * @param {Function|String} callback The callback to register as event handler\r\n * @param {Function|String} defaultCallback The callback to register as default handler\r\n * @returns {Object} An object to be used as a mixin, which sets up the listener for the given listenable.\r\n */\r\nmodule.exports = function(listenable,callback,initial){\r\n    return {\r\n        /**\r\n         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`\r\n         * and then make the call to `listenTo` with the arguments provided to the factory function\r\n         */\r\n        componentDidMount: function() {\r\n            for(var m in ListenerMethods){\r\n                if (this[m] !== ListenerMethods[m]){\r\n                    if (this[m]){\r\n                        throw \"Can't have other property '\"+m+\"' when using Reflux.listenTo!\";\r\n                    }\r\n                    this[m] = ListenerMethods[m];\r\n                }\r\n            }\r\n            this.listenTo(listenable,callback,initial);\r\n        },\r\n        /**\r\n         * Cleans up all listener previously registered.\r\n         */\r\n        componentWillUnmount: ListenerMethods.stopListeningToAll\r\n    };\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux/src/listenTo.js\n// module id = 18\n// module chunks = 0","var ListenerMethods = require('reflux-core/lib/ListenerMethods');\r\n\r\n/**\r\n * A mixin factory for a React component. Meant as a more convenient way of using the `listenerMixin`,\r\n * without having to manually set listeners in the `componentDidMount` method. This version is used\r\n * to automatically set up a `listenToMany` call.\r\n *\r\n * @param {Object} listenables An object of listenables\r\n * @returns {Object} An object to be used as a mixin, which sets up the listeners for the given listenables.\r\n */\r\nmodule.exports = function(listenables){\r\n    return {\r\n        /**\r\n         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`\r\n         * and then make the call to `listenTo` with the arguments provided to the factory function\r\n         */\r\n        componentDidMount: function() {\r\n            for(var m in ListenerMethods){\r\n                if (this[m] !== ListenerMethods[m]){\r\n                    if (this[m]){\r\n                        throw \"Can't have other property '\"+m+\"' when using Reflux.listenToMany!\";\r\n                    }\r\n                    this[m] = ListenerMethods[m];\r\n                }\r\n            }\r\n            this.listenToMany(listenables);\r\n        },\r\n        /**\r\n         * Cleans up all listener previously registered.\r\n         */\r\n        componentWillUnmount: ListenerMethods.stopListeningToAll\r\n    };\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux/src/listenToMany.js\n// module id = 19\n// module chunks = 0","\r\n/* globals React: false */\r\n\r\nvar Reflux = require('reflux-core');\r\nReflux.defineReact = require('./defineReact');\r\n\r\n// useful utility for ES6 work, mimics the ability to extend\r\nReflux.utils.inherits = function(subClass, superClass) {\r\n\tif (typeof superClass !== \"function\" && superClass !== null) {\r\n\t\tthrow new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\r\n\t}\r\n\tsubClass.prototype = Object.create(superClass && superClass.prototype, {\r\n\t\tconstructor: {\r\n\t\t\tvalue: subClass,\r\n\t\t\tenumerable: false,\r\n\t\t\twritable: true,\r\n\t\t\tconfigurable: true\r\n\t\t}\r\n\t});\r\n\tif (superClass) {\r\n\t\tif (Object.setPrototypeOf) {\r\n\t\t\tObject.setPrototypeOf(subClass, superClass);\r\n\t\t} else {\r\n\t\t\t/* jshint proto: true */\r\n\t\t\tsubClass.__proto__ = superClass;\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// first try to see if there's a global React var and use it\r\nif (typeof React !== 'undefined' && React) {\r\n\tReflux.defineReact(React);\r\n// otherwise we're gonna resort to 'try' stuff in case of other environments\r\n} else {\r\n\ttry {\r\n\t\tvar R = require(\"react\"); // we ignore this in browserify manually (see grunt file), so it's more of a doublecheck for in node\r\n\t\tReflux.defineReact(R);\r\n\t} catch (e) {}\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux/src/addES6.js\n// module id = 20\n// module chunks = 0","/* globals React: false */\r\n\r\nvar Reflux = require('reflux-core');\r\n\r\n/**\r\n * Reflux.defineReact function where you can manually supply\r\n * the React object in order to create in case Reflux needs to load before\r\n * React or there is a modular environment where there won't be a global\r\n * React variable.\r\n * @note The third param is for internal usage only.\r\n */\r\nvar _react, _defined = false;\r\nfunction defineReact(react, noLongerUsed, extend)\r\n{\r\n\tvar proto, _extend;\r\n\t\r\n\t// if no Reflux object is yet available then return and just wait until defineReact is called manually with it\r\n\ttry {\r\n\t\t_react  = react  || _react  || React;\r\n\t\t_extend = extend || _react.Component;\r\n\t} catch (e) {\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t// if Reflux and React aren't present then ignore, wait until they are properly present\r\n\t// also ignore if it's been called before UNLESS there's manual extending happening\r\n\tif (!_react || !_extend || (_defined && !extend)) {\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t// ----------- BEGIN Reflux.Component ------------\r\n\t/**\r\n\t * Reflux.Component:\r\n\t * An implementation for idiomatic React.js classes that mix with\r\n\t * Reflux stores. To utilize extend Reflux.Component instead of\r\n\t * React.Component. Then you may hook any Reflux store that has a\r\n\t * `this.state` property containing its state values to the component\r\n\t * via `this.store` or an Array of Reflux stores via `this.stores` in\r\n\t * the component's constructor (similar to how you assign initial state\r\n\t * in the constructor in ES6 style React). The default values of the\r\n\t * stores will automatically reflect in the component's state, and any\r\n\t * further `trigger` calls from that store will update properties passed\r\n\t * in the trigger into the component automatically.\r\n\t */\r\n\tvar RefluxComponent = function(props, context, updater) {\r\n\t\t_extend.call(this, props, context, updater);\r\n\t};\r\n\t\r\n\t// equivalent of `extends React.Component` or other class if provided via `extend` param\r\n\tReflux.utils.inherits(RefluxComponent, _extend);\r\n\t\r\n\tproto = RefluxComponent.prototype;\r\n\t\r\n\t/**\r\n\t * this.storeKeys\r\n\t * When this is a falsey value (null by default) the component mixes in\r\n\t * all properties from the stores attached to it and updates on changes\r\n\t * from all of them. When set to an array of string keys it will only\r\n\t * utilized state property names of those keys in any store attached. This\r\n\t * lets you choose which parts of stores update the component on a component-\r\n\t * by-component basis. If using this it is best set in the constructor.\r\n\t */\r\n\tproto.storeKeys = null;\r\n\t\r\n\t// on the mounting of the component that is where the store/stores are attached and initialized if needed\r\n\tproto.componentWillMount = function () {\r\n\t\t// if there is a this.store then simply push it onto the this.stores array or make one if needed\r\n\t\tif (this.store) {\r\n\t\t\tif (Array.isArray(this.stores)) {\r\n\t\t\t\tthis.stores.unshift(this.store);\r\n\t\t\t} else {\r\n\t\t\t\tthis.stores = [this.store];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (this.stores) {\r\n\t\t\tthis.__storeunsubscribes__ = this.__storeunsubscribes__ || [];\r\n\t\t\tvar sS = this.setState.bind(this);\r\n\t\t\t// this handles the triggering of a store, checking what's updated if proto.storeKeys is utilized\r\n\t\t\tvar onStoreTrigger = function(obj){\r\n\t\t\t\tvar updateObj = filterByStoreKeys(this.storeKeys, obj);\r\n\t\t\t\tif (updateObj) {\r\n\t\t\t\t\tsS(updateObj);\r\n\t\t\t\t}\r\n\t\t\t}.bind(this);\r\n\t\t\t// for each store in this.stores...\r\n\t\t\tfor (var i = 0, ii = this.stores.length; i < ii; i++) {\r\n\t\t\t\tvar str = this.stores[i];\r\n\t\t\t\t// if's a function then we know it's a class getting passed, not an instance\r\n\t\t\t\tif (typeof str === 'function') {\r\n\t\t\t\t\tvar storeId = str.id;\r\n\t\t\t\t\t// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so\r\n\t\t\t\t\tif (!str.singleton) {\r\n\t\t\t\t\t\tstr.singleton = new str();\r\n\t\t\t\t\t\tif (storeId) {\r\n\t\t\t\t\t\t\tReflux.stores[storeId] = str.singleton;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// before we weren't sure if we were working with an instance or class, so now we know an instance is created set it\r\n\t\t\t\t\t// to the variables we were using so that we can just continue on knowing it's the instance we're working with\r\n\t\t\t\t\tthis.stores[i] = str = str.singleton;\r\n\t\t\t\t\t// the instance should have an .id property as well if the class does, so set that here\r\n\t\t\t\t\tstr.id = storeId;\r\n\t\t\t\t\t// if there is an id and there is a global state property for this store then merge\r\n\t\t\t\t\t// the properties from that global state into the default state of the store AND then\r\n\t\t\t\t\t// set the global state to that new state (since it may have previously been partial)\r\n\t\t\t\t\tif (storeId && Reflux.GlobalState[storeId]) {\r\n\t\t\t\t\t\tfor (var key in Reflux.GlobalState[storeId]) {\r\n\t\t\t\t\t\t\tstr.state[key] = Reflux.GlobalState[storeId][key];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tReflux.GlobalState[storeId] = str.state;\r\n\t\t\t\t\t// otherwise (if it has an id) set the global state to the default state of the store\r\n\t\t\t\t\t} else if (storeId) {\r\n\t\t\t\t\t\tReflux.GlobalState[storeId] = str.state;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if no id, then no messing with global state\r\n\t\t\t\t}\r\n\t\t\t\t// listen/subscribe for the \".trigger()\" in the store, and track the unsubscribes so that we can unsubscribe on unmount\r\n\t\t\t\tif (!Reflux.serverMode) {\r\n\t\t\t\t\tthis.__storeunsubscribes__.push(str.listen(onStoreTrigger));\r\n\t\t\t\t}\r\n\t\t\t\t// run set state so that it mixes in the props from the store with the component\r\n\t\t\t\tvar updateObj = filterByStoreKeys(this.storeKeys, str.state);\r\n\t\t\t\tif (updateObj) {\r\n\t\t\t\t\tthis.setState(updateObj);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// mapStoreToState needs to know if is ready to map or must wait\r\n\t\tthis.__readytomap__ = true;\r\n\t\t// if there are mappings that were delayed, do them now\r\n\t\tvar dmaps = this.__delayedmaps__;\r\n\t\tif (dmaps) {\r\n\t\t\tfor (var j=0,jj=dmaps.length; j<jj; j++) {\r\n\t\t\t\tdmaps[j].func( dmaps[j].state );\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.__delayedmaps__ = null;\r\n\t};\r\n\t\r\n\t// on the unmount phase of the component unsubscribe that which we subscribed earlier to keep our garbage trail clean\r\n\tproto.componentWillUnmount = function () {\r\n\t\tif (this.__storeunsubscribes__) {\r\n\t\t\tfor (var i = 0, ii = this.__storeunsubscribes__.length; i < ii; i++) {\r\n\t\t\t\tthis.__storeunsubscribes__[i]();\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.__readytomap__ = false;\r\n\t};\r\n\t\r\n\t/**\r\n\t * this.mapStoreToState\r\n\t * This function allow you to supply map the state of a store to the\r\n\t * state of this component manually via your own logic. This method\r\n\t * is completely separate from this.store/this.stores and/or this.storeKeys.\r\n\t * Call this function with an ES6 store (class or singleton instance) as the\r\n\t * first argument and your filter function as the second. Your filter function\r\n\t * will receive an object of the parts of the ES6 store being updated every\r\n\t * time its setState is called. Your filter function then returns an object\r\n\t * which will be merged with the component state (IF it has any properties at all,\r\n\t * should you return a blank object the component will not rerender).\r\n\t */\r\n\tproto.mapStoreToState = function(store, filterFunc)\r\n\t{\r\n\t\t// make sure we have a proper singleton instance to work with\r\n\t\tif (typeof store === 'function') {\r\n\t\t\tif (store.singleton) {\r\n\t\t\t\tstore = store.singleton;\r\n\t\t\t} else {\r\n\t\t\t\tstore = Reflux.initStore(store);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// we need a closure so that the called function can remember the proper filter function to use, so function gets defined here\r\n\t\tvar self = this;\r\n\t\tfunction onMapStoreTrigger(obj) {\r\n\t\t\t// get an object \r\n\t\t\tvar update = filterFunc.call(self, obj);\r\n\t\t\t// if no object returned from filter functions do nothing\r\n\t\t\tif (!update) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// check if the update actually has any mapped props\r\n\t\t\t/*jshint unused: false */\r\n\t\t\tvar hasProps = false;\r\n\t\t\tfor (var check in update) {\r\n\t\t\t\thasProps = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t// if there were props mapped, then update via setState\r\n\t\t\tif (hasProps) {\r\n\t\t\t\tself.setState(update);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// add the listener to know when the store is triggered\r\n\t\tthis.__storeunsubscribes__ = this.__storeunsubscribes__ || [];\r\n\t\tthis.__storeunsubscribes__.push(store.listen(onMapStoreTrigger));\r\n\t\t\r\n\t\t// now actually run onMapStoreTrigger with the full store state so that we immediately have all store state mapped to component state\r\n\t\tif (this.__readytomap__) {\r\n\t\t\tonMapStoreTrigger(store.state);\r\n\t\t} else {\r\n\t\t\tthis.__delayedmaps__ = this.__delayedmaps__ || [];\r\n\t\t\tthis.__delayedmaps__.push({func:onMapStoreTrigger, state:store.state});\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * Reflux.Component.extend(OtherClass)\r\n\t * This allows you to get classes that extend off of another React.Component\r\n\t * inheriting class. For example if you're using a third party that uses\r\n\t * components that allow `class MyComponent extends LibComponent` (where LibComponent\r\n\t * itself extends React.Component) and you want to use that component with ES6 then\r\n\t * you can make a class `var MyDualComponent = Reflux.Component.extend(LibComponent);`\r\n\t * then you can use `class MyComponent extends MyDualComponent` to get the benefits\r\n\t * of both libraries.\r\n\t */\r\n\tRefluxComponent.extend = function(clss) {\r\n\t\treturn defineReact(null, null, clss);\r\n\t};\r\n\t\r\n\t// if is being manually called with an `extend` argument present then just return the created class\r\n\tif (extend) {\r\n\t\treturn RefluxComponent;\r\n\t}\r\n\t\r\n\t// otherwise set as Reflux.Component and continue with other normal definitions\r\n\tReflux.Component = RefluxComponent;\r\n\t\r\n\t// also set Reflux.PureComponent (if it exists) using the .extend feature\r\n\tif (_react.PureComponent) {\r\n\t\tReflux.PureComponent = RefluxComponent.extend(_react.PureComponent);\r\n\t}\r\n\t\r\n\t// ------------ END Reflux.Component ------------\r\n\t\r\n\t// --------- BEGIN Reflux.Store ------------\r\n\t/**\r\n\t * Reflux.Store:\r\n\t * Also implements optional Reflux.Store class that is idiomatic with\r\n\t * the React ES6 style. You extend Reflux.Store and then the rest works\r\n\t * the same as createStore, except the constructor instead of init, and\r\n\t * it holds state in a state property, and a .setState method is available\r\n\t * which automatically updates state and does a trigger. Then when using\r\n\t * with this.store or this.stores in an ES6 component just plass the class,\r\n\t * it will deal with a singleton instantiation of the class automatically.\r\n\t */\r\n\tvar RefluxStore = function() {\r\n\t\t// extending doesn't really work well here, so instead we create an internal instance\r\n\t\t// and just loop through its properties/methods and make a getter/setter for each\r\n\t\t// that will actually be getting and setting on that internal instance.\r\n\t\tthis.__store__ = Reflux.createStore();\r\n\t\tthis.state = {};\r\n\t\tvar self = this;\r\n\t\tfor (var key in this.__store__) {\r\n\t\t\t/*jshint loopfunc: true */\r\n\t\t\t(function (prop) {\r\n\t\t\t\tObject.defineProperty(self, prop, {\r\n\t\t\t\t\tget: function () { return self.__store__[prop]; },\r\n\t\t\t\t\tset: function (v) { self.__store__[prop] = v; }\r\n\t\t\t\t});\r\n\t\t\t})(key);\r\n\t\t}\r\n\t};\r\n\t\r\n\tproto = RefluxStore.prototype;\r\n\t\r\n\t// this defines the listenables property, mostly intended to be set as `this.listenables` in the constructor of the store\r\n\t// it is essentially a shortcut to the `listenToMany` method\r\n\tObject.defineProperty(proto, \"listenables\", {\r\n\t\tget: function () {\r\n\t\t\treturn this.__listenables__;\r\n\t\t},\r\n\t\tset: function (v) {\r\n\t\t\tvar Combined = {};\r\n\t\t\tif (Array.isArray(v)){\r\n\t\t\t\tv.forEach(function(obj) {\r\n\t\t\t\t\tfor (var key in obj) {\r\n\t\t\t\t\t\tCombined[key] = obj[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tCombined = v;\r\n\t\t\t}\r\n\t\t\tthis.__listenables__ = Combined;\r\n\t\t\tthis.listenToMany(Combined);\r\n\t\t},\r\n\t\tenumerable: true,\r\n\t\tconfigurable: true\r\n\t});\r\n\t\r\n\t// allows simple usage of `this.setState(obj)` within the store to both update the state and trigger the store to update\r\n\t// components that it is attached to in a simple way that is idiomatic with React\r\n\tproto.setState = function (obj) {\r\n\t\t// Object.assign(this.state, obj); // later turn this to Object.assign and remove loop once support is good enough\r\n\t\tfor (var key in obj) {\r\n\t\t\tthis.state[key] = obj[key];\r\n\t\t}\r\n\t\t// if there's an id (i.e. it's being tracked by the global state) then make sure to update the global state\r\n\t\tif (this.id) {\r\n\t\t\tReflux.GlobalState[this.id] = this.state;\r\n\t\t}\r\n\t\t// trigger, because any component it's attached to is listening and will merge the store state into its own on a store trigger\r\n\t\tthis.trigger(obj);\r\n\t};\r\n\t\r\n\t// this is a static property so that other code can identify that this is a Reflux.Store class\r\n\t// has issues specifically when using babel to transpile your ES6 stores for IE10 and below, not documented and shouldn't use yet\r\n\tObject.defineProperty(RefluxStore, \"isES6Store\", {\r\n\t\tget: function () {\r\n\t\t\treturn true;\r\n\t\t},\r\n\t\tenumerable: true,\r\n\t\tconfigurable: true\r\n\t});\r\n\t\r\n\t// allows a shortcut for accessing MyStore.singleton.state as MyStore.state (since common usage makes a singleton)\r\n\tObject.defineProperty(RefluxStore, \"state\", {\r\n\t\tget: function () {\r\n\t\t\tif (!this.singleton) {\r\n\t\t\t\tthrow new Error('Reflux.Store.state is inaccessible before the store has been initialized.');\r\n\t\t\t}\r\n\t\t\treturn this.singleton.state;\r\n\t\t},\r\n\t\tenumerable: true,\r\n\t\tconfigurable: true\r\n\t});\r\n\t\r\n\t/* NOTE:\r\n\tIf a Reflux.Store definition is given a static id property and used\r\n\tproperly within a Reflux.Component or with Reflux.initStore then\r\n\tit will be added to the Reflux.GlobalState object which automatically tracks the\r\n\tcurrent state of all such defined stores in the program. */\r\n\t\r\n\tReflux.Store = RefluxStore;\r\n\t// ----------- END Reflux.Store -------------\r\n\t\r\n\t// --------- BEGIN Reflux Static Props/Methods ------------\r\n\t/**\r\n\t * Reflux.GlobalState is where data is stored for any Reflux.Store that has a static id property. Each store's\r\n\t * state will be on the Reflux.GlobalState object with the id as the key. So a store with the id \"MyStore\" and\r\n\t * a state {\"color\":\"red\"} will end up with a Reflux.GlobalState of {\"MyStore\":{\"color\":\"red\"}}\r\n\t * Reflux.GlobalState is an accessible part of the API. However, keep in mind that non-primitive properties you\r\n\t * read off of it will continue to mutate and you can only manually mutate Reflux.GlobalState BEFORE any component\r\n\t * mounting of components with ES6 stores. For more functionality look to Reflux.setGlobalState to change the global\r\n\t * state at any point, and Reflux.getGlobalState to return a deep clone of the Reflux.GlobalState object which will\r\n\t * not continue to mutate as Reflux.GlobalState continues to mutate.\r\n\t */\r\n\tReflux.GlobalState = Reflux.GlobalState || {};\r\n\t\r\n\t/**\r\n\t * Reflux.stores\r\n\t * All initialized stores that have an id will have a reference to their singleton stored here with the key being the id.\r\n\t */\r\n\tReflux.stores = {};\r\n\t\r\n\t/**\r\n\t * Reflux.getGlobalState takes no arguments, and returns a deep clone of Reflux.GlobalState \r\n\t * which will not continue to mutate as Reflux.GlobalState does. It can essentially store\r\n\t * snapshots of the global state as the program goes for saving or for in-app time travel.\r\n\t */\r\n\tReflux.getGlobalState = function() {\r\n\t\treturn clone(Reflux.GlobalState);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Reflux.setGlobalState takes one argument that is a representation of the a possible\r\n\t * global state. It updates all stores in the program to represent data in that given state.\r\n\t * This includes triggering those stores so that that state is represented in any Reflux.Component\r\n\t * instances they are attached to. Partial states may be given to it, and only the represented\r\n\t * stores/state values will be updated.\r\n\t */\r\n\tReflux.setGlobalState = function(obj) {\r\n\t\tfor (var storeID in obj) {\r\n\t\t\tif (Reflux.stores[storeID]) {\r\n\t\t\t\tReflux.stores[storeID].setState(obj[storeID]);\r\n\t\t\t} else {\r\n\t\t\t\tReflux.GlobalState[storeID] = obj[storeID];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * Reflux.initStore takes one argument (a class that extends Reflux.Store) and returns a singleton\r\n\t * intance of that class. Its main functionality is to be able to mimic what happens to stores attached to\r\n\t * this.store or this.stores during the mounting phase of a component without having to actually attach the\r\n\t * store to a component in order to work properly with the global state.\r\n\t */\r\n\t// Reflux.initializeGlobalStore is kept for backwards compatibility, but deprecated since the function is\r\n\t// now for more broad instantiation of globally stored AND non-globally stored classes\r\n\tReflux.initializeGlobalStore = Reflux.initStore = function(str) {\r\n\t\tvar storeId = str.id;\r\n\t\t// if they're initializing something twice then we're done already, return it\r\n\t\tif (str.singleton) {\r\n\t\t\treturn str.singleton;\r\n\t\t}\r\n\t\t// if no id then it's easy: just make new instance and set to singleton\r\n\t\tif (!storeId) {\r\n\t\t\tstr.singleton = new str();\r\n\t\t\treturn str.singleton;\r\n\t\t}\r\n\t\t// create the singleton and assign it to the class's singleton static property\r\n\t\tvar inst = str.singleton = new str();\r\n\t\t// store it on the Reflux.stores array to be accessible later\r\n\t\tReflux.stores[storeId] = inst;\r\n\t\t// the singleton instance itself should also have the id property of the class\r\n\t\tinst.id = storeId;\r\n\t\t// if the global state has something set for this id, copy it to the state and then\r\n\t\t// make sure to set the global state to the end result, since it may have only been partial\r\n\t\tif (Reflux.GlobalState[storeId]) {\r\n\t\t\tfor (var key in Reflux.GlobalState[storeId]) {\r\n\t\t\t\tinst.state[key] = Reflux.GlobalState[storeId][key];\r\n\t\t\t}\r\n\t\t\tReflux.GlobalState[storeId] = inst.state;\r\n\t\t// otherwise just set the global state to the default state of the class\r\n\t\t} else {\r\n\t\t\tReflux.GlobalState[storeId] = inst.state;\r\n\t\t}\r\n\t\t// returns the singleton itself, though it will also be accessible as as `MyClass.singleton`\r\n\t\treturn inst;\r\n\t};\r\n\t// --------- END Reflux Static Props/Methods ------------\r\n\t\r\n\t// so it knows not to redefine Reflux static stuff and stores if called again\r\n\t_defined = true;\r\n}\r\n\r\n// filters a state object by storeKeys array (if it exists)\r\n// if filtering and obj contains no properties to use, returns false to let the component know not to update\r\nfunction filterByStoreKeys(storeKeys, obj)\r\n{\r\n\t// if there are not storeKeys defined then simply return the whole original object\r\n\tif (!storeKeys) {\r\n\t\treturn obj;\r\n\t}\r\n\t// otherwise go through and only update properties that are in the storeKeys array, and return straight false if there are none\r\n\tvar doUpdate = false;\r\n\tvar updateObj = {};\r\n\tfor (var i = 0, ii = storeKeys.length; i < ii; i++) {\r\n\t\tvar prop = storeKeys[i];\r\n\t\tif (obj.hasOwnProperty(prop)) {\r\n\t\t\tdoUpdate = true;\r\n\t\t\tupdateObj[prop] = obj[prop];\r\n\t\t}\r\n\t}\r\n\treturn doUpdate ? updateObj : false;\r\n}\r\n\r\n// this is utilized by some of the global state functionality in order to get a clone that will\r\n// not continue to be modified as the GlobalState mutates\r\nfunction clone(frm, to) {\r\n\tif (frm === null || typeof frm !== \"object\") {\r\n\t\treturn frm;\r\n\t}\r\n\tif (frm.constructor !== Object && frm.constructor !== Array) {\r\n\t\treturn frm;\r\n\t}\r\n\tif (frm.constructor === Date || frm.constructor === RegExp || frm.constructor === Function ||\r\n\t\tfrm.constructor === String || frm.constructor === Number || frm.constructor === Boolean) {\r\n\t\treturn new frm.constructor(frm);\r\n\t}\r\n\tto = to || new frm.constructor();\r\n\tfor (var name in frm) {\r\n\t\tto[name] = typeof to[name] === \"undefined\" ? clone(frm[name], null) : to[name];\r\n\t}\r\n\treturn to;\r\n}\r\n\r\nmodule.exports = defineReact;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reflux/src/defineReact.js\n// module id = 21\n// module chunks = 0","if(typeof __WEBPACK_EXTERNAL_MODULE_22__ === 'undefined') {var e = new Error(\"Cannot find module \\\"undefined\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e;}\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_22__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 22\n// module chunks = 0"],"sourceRoot":""}